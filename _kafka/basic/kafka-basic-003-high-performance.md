---
title: "Kafka 如何实现高吞吐量和性能"
sequence: "103"
---

![](/assets/images/kafka/basic/kafka-basic-high-performance-005.png)

## 操作系统

### 读写-内存-页缓存技术

Kafka 是基于 **操作系统** 的页缓存来实现文件写入的。

操作系统本身有一层缓存，叫做 **page cache**，是在 **内存里的缓存**，我们也可以称之为 **os cache**，意思就是操作系统自己管理的缓存。

Kafka 在写入磁盘文件的时候，可以直接写入这个 os cache 里，也就是仅仅写入内存中，
接下来由操作系统自己决定什么时候把 os cache 里的数据真的刷入磁盘文件中。
通过这一个步骤，就可以将磁盘文件写性能提升很多了，因为其实这里相当于是在写内存，不是在写磁盘，原理图如下：

![](/assets/images/kafka/basic/kafka-os-cache.png)

**PageCache 页缓存**：Kafka 重度依赖底层操作系统提供的 PageCache 功能。
当上层有写操作时，操作系统只是将数据写入 PageCache。
当读操作发生时，先从 PageCache 中查找；如果查找不到，再去磁盘中读取。
实际上，PageCache 是把尽可能多的空闲内存都当做了磁盘缓存来使用。

### 读-零拷贝

大家应该都知道，从 Kafka 里经常要消费数据，
那么消费的时候实际上就是要从 kafka 的**磁盘文件**里**读取某条数据**然后发送给下游的消费者，如下图所示。

![](/assets/images/kafka/basic/kafka-high-performance-002.png)

那么这里如果频繁的从磁盘读数据然后发给消费者，会增加**两次**没必要的拷贝，如下图：

![](/assets/images/kafka/basic/kafka-high-performance-003.png)

一次是从操作系统的 cache 里拷贝到应用进程的缓存里，接着又从应用程序缓存里拷贝回操作系统的 Socket 缓存里。

而且为了进行这两次拷贝，中间还发生了好几次上下文切换，一会儿是应用程序在执行，一会儿上下文切换到操作系统来执行。所以这种方式来读取数据是比较消耗性能的。

**Kafka 为了解决这个问题，在读数据的时候是引入零拷贝技术。**

也就是说，直接让操作系统的 cache 中的数据发送到**网卡**后传输给下游的消费者，**中间跳过了两次拷贝数据的步骤**，
Socket 缓存中仅仅会拷贝一个描述符过去，不会拷贝数据到 Socket 缓存，如下图所示：

![](/assets/images/kafka/basic/kafka-high-performance-004.png)

通过 **零拷贝技术**，就不需要把 os cache 里的数据拷贝到应用缓存，再从应用缓存拷贝到 Socket 缓存了，两次拷贝都省略了，所以叫做零拷贝。

对 Socket 缓存，仅仅就是拷贝数据的描述符过去，然后数据就直接从 os cache 中发送到网卡上去了，这个过程大大的提升了数据消费时读取文件数据的性能。

Kafka 从磁盘读数据的时候，会先看看 os cache 内存中是否有，如果有的话，其实读数据都是直接读内存的。

kafka 集群经过良好的调优，数据直接写入 os cache 中，然后读数据的时候也是从 os cache 中读。
相当于 Kafka 完全基于内存提供数据的写和读了，所以这个整体性能会极其的高。

## 磁盘层面

### 分区-读写

1、Kafka 本身是分布式集群，可以采用分区技术，并行度高。

### 写-磁盘-磁盘顺序写

另一个主要功能是 kafka 写数据的时候，是以磁盘顺序写的方式来写的。
也就是说，**仅仅将数据追加到文件的末尾，不是在文件的随机位置来修改数据**。

普通的机械磁盘如果你要是随机写的话，确实性能极差，也就是随便找到文件的某个位置来写数据。

但是如果你是 追加文件末尾 按照顺序的方式来写数据的话，那么这种磁盘顺序写的性能基本上可以跟写内存的性能相差无几。

基于上面两点，kafka 就实现了写入数据的超高性能。

### Segment 层面-读

2、**读**数据采用**稀疏索引**，可以快速定位要消费的数据。

