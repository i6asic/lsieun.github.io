---
title: "Redis"
sequence: "103"
---

- [ ] CAP
- [ ] Raft
- [ ] 强一致性
- [ ] 延时双删 + 分布式锁

## Redis 使用

### Redis 的数据结构

## 说说 Redis 的基本数据结构类型

大多数小伙伴都知道，Redis 有以下这五种基本类型：

- String（字符串）
- Hash（哈希）
- List（列表）
- Set（集合）
- zset（有序集合）

它还有三种特殊的数据结构类型

- Geospatial
- Hyperloglog
- Bitmap

redis 的持久化方式，以及项目中用的哪种，为什么

redis 集群的理解，怎么动态增加或者删除一个节点，而保证数据不丢失。

## Redis 为什么这么快？

### 基于内存存储实现

我们都知道内存读写是比在磁盘快很多的，Redis 基于内存存储实现的数据库，相对于数据存在磁盘的 MySQL 数据库，省去磁盘 I/O 的消耗。

### 高效的数据结构

我们知道，Mysql 索引为了提高效率，选择了 B+ 树的数据结构。其实合理的数据结构，就是可以让你的应用/程序更快。

### 合理的线程模型

多路 I/O 复用技术可以让单个线程高效的处理多个连接请求，而 Redis 使用用 epoll 作为 I/O 多路复用技术的实现。
并且，Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间。

### 单线程模型

Redis 是单线程模型的，而单线程避免了 CPU 不必要的上下文切换和竞争锁的消耗。
也正因为是单线程，如果某个命令执行过长（如 hgetall 命令），会造成阻塞。
Redis 是面向快速执行场景的数据库。，所以要慎用如 smembers 和 lrange、hgetall 等命令。


## 什么是缓存击穿、缓存穿透、缓存雪崩

三者出现的根本原因是：Redis 缓存命中率下降，请求直接打到 DB 上了

### 缓存穿透问题

先来看一个常见的缓存使用方式：读请求来了，先查下缓存，缓存有值命中，就直接返回；缓存没命中，就去查数据库，然后把数据库的值更新到缓存，再返回。

**缓存穿透**：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，
这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。

通俗点说，读请求访问时，缓存和数据库都没有某个值，这样就会导致每次对这个值的查询请求都会穿透到数据库，这就是缓存穿透。

缓存穿透一般都是这几种情况产生的：

- 业务不合理的设计，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个 userid 查询有没有守护。
- 业务/运维/开发失误的操作，比如缓存和数据库的数据都被误删除了。
- 黑客非法请求攻击，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。

如何避免缓存穿透呢？ 一般有三种方法。

1.如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。
2.如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）
3.使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。

### 缓存雪崩问题

**缓存雪崩**：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至 down 机。

- 缓存雪崩一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。
  如采用一个较大固定值 + 一个较小的随机值，5 小时 +0 到 1800 秒酱紫。
- Redis 故障宕机也可能引起缓存雪崩。这就需要构造 Redis 高可用集群啦。

### 缓存击穿问题

**缓存击穿**：指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个 Key 有大量的并发请求过来，从而大量的请求打到 db。

缓存击穿看着有点像，其实它两区别是，缓存雪崩是指数据库压力过大甚至 down 机，缓存击穿只是大量并发请求到了 DB 数据库层面。
可以认为击穿是缓存雪崩的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点 key 缓存，雪崩则是很多 key。

解决方案就有两种：

1.使用互斥锁方案。缓存失效时，不是立即去加载 db 数据，而是先使用某些带成功返回的原子操作命令，如(Redis 的 setnx）去操作，成功的时候，再去加载 db 数据库数据和设置缓存。否则就去重试获取缓存。
2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。

## 说说 Redis 的常用应用场景

- 缓存
- 排行榜
- 计数器应用
- 共享 Session
- 分布式锁
- 社交网络
- 消息队列
- 位操作

### 缓存

我们一提到 redis，自然而然就想到缓存，国内外中大型的网站都离不开缓存。
合理的利用缓存，比如缓存热点数据，不仅可以提升网站的访问速度，还可以降低数据库 DB 的压力。
并且，Redis 相比于 memcached，还提供了丰富的数据结构，并且提供 RDB 和 AOF 等持久化机制，强的一批。

### 排行榜

当今互联网应用，有各种各样的排行榜，如电商网站的月度销量排行榜、社交 APP 的礼物排行榜、小程序的投票排行榜等等。
Redis 提供的 zset 数据类型能够实现这些复杂的排行榜。

比如，用户每天上传视频，获得点赞的排行榜可以这样设计：

1.用户 Jay 上传一个视频，获得 6 个赞，可以酱紫：
zadd user:ranking:2021-03-03 Jay 3
2.过了一段时间，再获得一个赞，可以这样：
zincrby user:ranking:2021-03-03 Jay 1
3.如果某个用户 John 作弊，需要删除该用户：
zrem user:ranking:2021-03-03 John
4.展示获取赞数最多的 3 个用户
zrevrangebyrank user:ranking:2021-03-03 0 2

### 计数器应用

各大网站、APP 应用经常需要计数器的功能，如短视频的播放数、电商网站的浏览数。
这些播放数、浏览数一般要求实时的，每一次播放和浏览都要做加 1 的操作，如果并发量很大对于传统关系型数据的性能是一种挑战。
Redis 天然支持计数功能而且计数的性能也非常好，可以说是计数器系统的重要选择。

### 共享 Session

如果一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，用户刷新一次可能就需要重新登录了，这样显然有问题。
实际上，可以使用 Redis 将用户的 Session 进行集中管理，每次用户更新或者查询登录信息都直接从 Redis 中集中获取。

### 分布式锁

几乎每个互联网公司中都使用了分布式部署，分布式服务下，就会遇到对同一个资源的并发访问的技术难题，如秒杀、下单减库存等场景。

用 synchronize 或者 reentrantlock 本地锁肯定是不行的。
如果是并发量不大话，使用数据库的悲观锁、乐观锁来实现没啥问题。
但是在并发量高的场合中，利用数据库锁来控制资源的并发访问，会影响数据库的性能。
实际上，可以用 Redis 的 setnx 来实现分布式的锁。

### 社交网络

赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，
而且传统的关系型数据不太适保存 这种类型的数据，Redis 提供的数据结构可以相对比较容易地实现这些功能。

### 消息队列

消息队列是大型网站必用中间件，如 ActiveMQ、RabbitMQ、Kafka 等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。
Redis 提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

### 位操作

用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。
腾讯 10 亿用户，要几个毫秒内查询到某个用户是否在线，能怎么做？千万别说给每个用户建立一个 key，
然后挨个记（你可以算一下需要的内存会很恐怖，而且这种类似的需求很多。这里要用到位操作——使用 setbit、getbit、bitcount 命令。
原理是：redis 内构建一个足够长的数组，每个数组元素只能是 0 和 1 两个值，然后这个数组的下标 index 用来表示用户 id（必须是数字哈），
那么很显然，这个几亿长的大数组就能通过下标和元素值（0 和 1）来构建一个记忆系统。

## Redis 的持久化机制有哪些？优缺点说说

Redis 是基于内存的非关系型 K-V 数据库，既然它是基于内存的，如果 Redis 服务器挂了，数据就会丢失。
为了避免数据丢失了，Redis 提供了持久化，即把数据保存到磁盘。

Redis 提供了 RDB 和 AOF 两种持久化机制，它持久化文件加载流程如下：

### RDB

RDB，就是把内存数据以快照的形式保存到磁盘上。

```text
RDB 可能是 redis database 的缩写
```

什么是快照 ? 可以这样理解，给当前时刻的数据，拍一张照片，然后保存下来。

RDB 持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是 Redis 默认的持久化方式。
执行完操作后，在指定目录下会生成一个 dump.rdb 文件，Redis 重启的时候，通过加载 dump.rdb 文件来恢复数据。RDB 触发机制主要有以下几种：

RDB 的优点

- 适合大规模的数据恢复场景，如备份，全量复制等

RDB 缺点

- 没办法做到实时持久化/秒级持久化。
- 新老版本存在 RDB 格式兼容问题

### AOF

AOF（append only file） 持久化，采用日志的形式来记录每个写操作，追加到文件中，
重启时再重新执行 AOF 文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。

AOF 的优点

- 数据的一致性和完整性更高

AOF 的缺点

- AOF 记录的内容越多，文件越大，数据恢复变慢。

## 怎么实现 Redis 的高可用？

我们在项目中使用 Redis，肯定不会是单点部署 Redis 服务的。
因为，单点部署一旦宕机，就不可用了。为了实现高可用，通常的做法是，将数据库复制多个副本以部署在不同的服务器上，其中一台挂了也可以继续提供服务。

Redis 实现高可用有三种部署模式：**主从模式**，**哨兵模式**，**集群模式**。

### 主从模式

主从模式中，Redis 部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是**主从复制**机制

主从复制包括**全量复制**，**增量复制**两种。一般当 slave 第一次启动连接 master，或者认为是第一次连接，就采用全量复制。

1.slave 发送 sync 命令到 master。
2.master 接收到 SYNC 命令后，执行 bgsave 命令，生成 RDB 全量文件。
3.master 使用缓冲区，记录 RDB 快照生成期间的所有写命令。
4.master 执行完 bgsave 后，向所有 slave 发送 RDB 快照文件。
5.slave 收到 RDB 快照文件后，载入、解析收到的快照。
6.master 使用缓冲区，记录 RDB 同步期间生成的所有写的命令。
7.master 快照发送完毕后，开始向 slave 发送缓冲区中的写命令 ;
8.salve 接受命令请求，并执行来自 master 缓冲区的写命令

### 哨兵模式

主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。
显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。

**哨兵模式**，由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，
并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。
但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。

简单来说，哨兵模式就三个作用：

- 发送命令，等待 Redis 服务器（包括主服务器和从服务器）返回监控其运行状态；
- 哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；
- 哨兵之间还会相互监控，从而达到高可用。

### Cluster 集群模式

哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。
但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。
因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的分布式存储。
对数据进行分片，也就是说每台 Redis 节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。

## 在生成 RDB 期间，Redis 可以同时处理写请求么？

可以的，Redis 提供两个指令生成 RDB，分别是 save 和 bgsave。

如果是 save 指令，会阻塞，因为是主线程执行的。
如果是 bgsave 指令，是 fork 一个子进程来写入 RDB 文件的，快照持久化完全交给子进程来处理，父进程则可以继续处理客户端的请求。

## 布隆过滤器

应对缓存穿透问题，我们可以使用布隆过滤器。布隆过滤器是什么呢？

布隆过滤器是一种占用空间很小的数据结构，它由一个很长的二进制向量和一组 Hash 映射函数组成，它用于检索一个元素是否在一个集合中，
空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。

布隆过滤器原理是？假设我们有个集合 A，A 中有 n 个元素。
利用 k 个哈希散列函数，将 A 中的每个元素映射到一个长度为 a 位的数组 B 中的不同位置上，这些位置上的二进制数均设置为 1。
如果待检查的元素，经过这 k 个哈希散列函数的映射后，发现其 k 个位置上的二进制数全部为 1，这个元素很可能属于集合 A，反之，一定不属于集合 A。

## MySQL 与 Redis 如何保证双写一致性

- 缓存延时双删：第 1 步，删除 Redis 数据；第 2 步，更新数据库；第 3 步，等一会儿，别的线程可能读了“旧数据”，还没有放到 Redis 当中去；第 4 步，休眠 500ms，再次删除。
- 删除缓存重试机制
- 使用阿里的 Cannal，读取 biglog 异步删除缓存

- [如何保证 Redis 缓存与数据库数据一致性的](https://www.bilibili.com/video/BV11N411H7HN/)

## Reference

- [Redis 系列九：redis 集群高可用](https://www.cnblogs.com/leeSmall/p/8414687.html)
