---
title: "Redis 为什么快？"
sequence: "101"
---

- 基础
    - 纯内存访问
    - 单线程避免上下文切换
- 进阶
    - 渐进式 ReHash
    - 缓存时间戳

## Redis 的 Key 和 Value 的数据组织结构

### 全局哈希表

为了实现从 key 到 value 的快速访问，Redis 使用了一个哈希表来保存所有 key-value pair。
一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。
所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了 key-value pair 数据。

![](/assets/images/redis/mechanism/redis-global-hash-table.png)

哈希桶中的 entry 元素中保存了 key 和 value 的指针，分别指向了实际的键和值，这样一来，
即使是一个集合，也是通过 value 指针被查找到。
因为这个哈希表保存了所有的键值对，所以，也把它称为 **全局哈希表**。

哈希表的最大好处很明显，就是让我们可以用 `O(1)` 的时间复杂度来快速查找到 key-value pair：
我们只需要计算 key 的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。

但是，当我们往 Redis 中写入大量数据后，就可能发现操作有时间会突然变慢了。
这是因为一个潜在的风险点：哈希表的冲突问题 和 ReHash 可能带来的操作阻塞。

当我们往哈希表中写入更多数据时，哈希冲突是不可避免的问题。
这里的哈希冲突，两个 key 的哈希值和哈希桶计算对应关系时，正好落在同一个哈希桶中。

![](/assets/images/redis/mechanism/redis-global-hash-table-hash-collision.png)

Redis 解决哈希冲突的方式，就是链式哈希。
链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

如果这个数组一直不变，那么 hash 冲突会变很多，这个时候检索效率会大打折扣，
所以，Redis 就需要把数组进行扩容（一般是扩大到原来的两倍）；
但是，问题也随之而来，扩容后每个 hash 桶的数据会分散到不同的位置，
这里涉及到元素的移动，必定会阻塞 IO，所以这个 ReHash 过程会导致很多请求阻塞。

## 渐进式 ReHash

为了避免这个问题，Redis 采用了渐进式 ReHash。

首先，Redis 默认使用了两个全局哈希表：**哈希表1** 和 **哈希表2**.
一开始，当刚插入数据时，默认使用**哈希表1**；此时，**哈希表2** 并没有被分配空间。
随着数据逐步增多，Redis 开始执行 rehash。

- 第 1 步，给 **哈希表2** 分配更大的空间，例如是当前 **哈希表1** 大小的两倍。
- 第 2 步，将 **哈希表1** 中的数据重新映射并拷贝到 **哈希表2** 中。
- 第 3 步，释放 **哈希表1** 的空间。

在上面的第 2 步涉及大量的数据拷贝，如果一次性把 **哈希表1** 中的数据都迁移完，
会造成 Redis 线程阻塞，无法服务其它请求。
此时，Redis 就无法快速访问数据了。

![](/assets/images/redis/mechanism/redis-global-hash-table-rehash.png)

在 Redis 开始执行 rehash 时，Redis 仍然正常处理客户端请求，但是要加入一个额外的处理：

- 处理第 1 个请求时，把 **哈希表1** 中的第 1 个索引位置上的所有 entries 拷贝到 **哈希表2** 中
- 第理第 2 个请求时，把 **哈希表1** 中的第 2 个索引位置上的所有 entries 拷贝到 **哈希表2** 中
- 如何循环，直到把所有的索引位置的数据都拷贝到 **哈希表2** 中

这样，就巧妙地把一次性大量拷贝的开销，分摊到了多次请求的过程中，避免了耗时操作，保证了数据的快速访问。
所以，这里基础上也确保根据 key 找 value 的操作在 `O(1)` 左右。

不过，这里要注意，如果 Redis 中有海量的 key 的值话，这个 ReHash 过程会很长很长，虽然采用渐进式 ReHash，
但在 ReHash 的过程中，还是会导致请求有不小的卡顿，并且一些统计命令也会非常卡顿，例如 `keys`

按照 Redis 的配置，每个实例能存储的最大的 key 的数量为 2 的 32 次方，即 2.5 亿；
但是，尽量把 key 的数量控制在千万以下，这样就避免 Rehash 导致的卡顿问题；
如果数量确实比较多，建议采用分区 hash 存储。


## 为什么 Redis 要缓存系统时间戳

我们平时使用系统时间戳，常常是不加思索地使用 `System.currentTimeMillis()` 来获取系统的毫秒时间戳。

Redis 不能这样，因为每一次获取系统时间戳，都是一次系统调用；
系统调用，相对来说，是比较费时间的，作为单线程的 Redis 承受不起，所以它需要对时间进行缓存：
由一个定时任务，每毫秒更新一次时间缓存，获取时间都是从缓存中直接拿。



