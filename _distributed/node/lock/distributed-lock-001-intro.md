---
title: "分布式锁"
sequence: "101"
---

## 概念

### 什么是分布式锁？

线程锁和进程锁仅能满足在单机 JVM 或者同一个操作系统下，才能有效。
跨 JVM 系统，无法满足。
因此就产生了分布式锁，完成锁的工作。

### 对比：分布式锁和普通锁对比

<table>
    <thead>
    <tr>
        <th></th>
        <th>普通锁（本地锁）</th>
        <th>分布式锁</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>作用范围</td>
        <td>
            单个进程或单个计算机内的多个线程之间的同步。
            当多个线程尝试访问同一资源时，普通锁可以确保只有一个线程可以访问该资源，其他线程需要等待锁的释放。
        </td>
        <td>分布式锁用于跨多个进程或多个计算机之间的同步。允许不同的进程或计算机协调对共享资源的访问，以避免冲突和数据不一致性。</td>
    </tr>
    <tr>
        <td>锁的获取方式</td>
        <td>
            普通锁通常是基于本地内存的互斥量或自旋锁实现的，可以通过在内存中的标记或计数器来判断锁的状态，并通过执行 CPU 自旋等待来获取锁。
        </td>
        <td>
            分布式锁通常使用基于分布式系统的外部组件或服务，如分布式缓存系统（如 Redis）或分布式协调服务（如 ZooKeeper）实现。
            进程或计算机通过与这些组件进行通信来获取和释放锁。
        </td>
    </tr>
    <tr>
        <td>可靠性和容错性</td>
        <td>普通锁在单个计算机上运行，受限于该计算机的可靠性和容错性。如果计算机故障或程序崩溃，可能会导致锁被永久占用或意外释放。</td>
        <td>
            分布式锁通过将锁状态存储在外部组件中，可以提供更高的可靠性和容错性。
            即使其中一个计算机或进程崩溃，其他进程仍然可以通过与外部组件通信来获取锁。
        </td>
    </tr>
    </tbody>
</table>

## 分布式锁特点

分布式锁，需要考虑几部分内容：

- 功能，即“获取锁”和“释放锁”
- 性能：获取“锁”之后，“并行”就变成了“串行”，就会影响执行速度，如何更快
- 高可用，
- 安全性：死锁

```text
                    ┌─── client ───┼─── unique id
                    │
Distributed Lock ───┤                                  ┌─── lock
                    │              ┌─── function ──────┤
                    │              │                   └─── unlock
                    └─── server ───┤
                                   │                   ┌─── low
                                   └─── performance ───┤
                                                       └─── high
```

### 基础版

锁的基本功能有两个：

- 获取锁（lock）
- 释放锁（unlock）

一个基础的分布式锁具有三个特性：

- **互斥**：在分布式高并发的条件下，需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点。
- **可重入**：我们知道 ReentrantLock 是可重入锁，那它的特点就是同一个线程可以重复拿到同一个资源的锁。
- **防止死锁**：在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令，导致其它线程都无法获得锁，造成死锁。

```text
- 基础的分布式锁特性
    - 获取锁
        - 对别人：互斥
        - 对自己：可重入
    - 释放锁：
        - 防止死锁
```

### 进阶版

```text
                    ┌─── client ───┼─── unique id
                    │
                    │                                                               ┌─── other: exclusive
                    │                                                ┌─── lock ─────┤
                    │                                                │              └─── self: reentrancy
                    │                                  ┌─── space ───┤
Distributed Lock ───┤                                  │             │              ┌─── self ---> self
                    │                                  │             └─── unlock ───┤
                    │              ┌─── function ──────┤                            └─── other -x-> self
                    │              │                   │
                    │              │                   │             ┌─── eternal ─────┼─── rare: self down --> deadlock
                    │              │                   └─── time ────┤
                    └─── server ───┤                                 │                 ┌─── rare: self work not finished
                                   │                                 └─── temporary ───┤
                                   │                                                   └─── watchdog: prolongs the expiration
                                   │
                                   │                   ┌─── lock scope
                                   └─── performance ───┤
                                                       └─── read write lock
```

- 特点
    - 功能
        - 获取锁
            - 空间：
                - 对它：互斥
                - 对己：可重入
            - 时间
                - 自动续期
        - 释放锁
            - 死锁：锁超时释放
    - 性能
        - 高性能
            - 读写锁

- 特点
    - 互斥：只能有一个客户端持有锁
    - 避免死锁
        - 引入过期时间
        - 锁附加唯一性
        - 自动续期
        - 可重入
    - 容错

分布式锁需要具备哪些条件？

- 互斥性：任意时刻，只能有一个客户端才能获取锁
- 可重入性：允许同一个线程或客户端在持有锁的情况下多次获取同一个锁，而不会出现死锁或阻塞的情况。
- 自动续期
- 防止死锁：分布式锁应该设计成在锁的持有者异常退出或崩溃时能够自动释放，以防止死锁的发生。
  一般通过设置合适的锁超时时间来避免死锁。
- 高可用性：在节点故障时也能正常工作，确保锁的可靠性。
  这对于递归函数调用等场景尤其重要。
- 唯一标识：分布式锁应该具备唯一的标识，以便客户端可以识别和管理不同的锁。

## 实现方式

实现分布式锁的方式有以下几种：

- 使用 MySQL：基于唯一索引。
- 使用 ZooKeeper：基于临时有序节点。
- 使用 Redis：基于 `SETNX` 命令。

实现分布式锁的三种方式对比：

- 理解的容易程度：数据库 > 缓存 > ZooKeeper
- 实现的复杂性：ZooKeeper >= 缓存 > 数据库
- 性能：缓存 > ZooKeeper >= 数据库
- 可靠性：ZooKeeper > 缓存 > 数据库

ZooKeeper 分布式锁的可靠性最高，有封装好的框架，很容易实现分布式锁的功能，并且几乎解决了数据库锁和缓存式锁的不足，因此是实现分布式锁的首选方法。

<table>
    <thead>
    <tr>
        <th></th>
        <th>MySQL</th>
        <th>ZooKeeper</th>
        <th>Redis</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>互斥</td>
        <td>利用 MySQL 本身的互斥锁机制</td>
        <td>利用节点的<b>唯一性</b>和<b>有序性</b>实现互斥</td>
        <td>利用 <code>SETNX</code> 互斥命令</td>
    </tr>
    <tr>
        <td>高可用</td>
        <td>好</td>
        <td>好</td>
        <td>好</td>
    </tr>
    <tr>
        <td>高性能</td>
        <td>一般</td>
        <td>一般</td>
        <td>好</td>
    </tr>
    <tr>
        <td>安全性</td>
        <td>断开连接，自动释放</td>
        <td>临时节点，断开连接自动释放</td>
        <td>利用锁超时时间，到期释放</td>
    </tr>
    </tbody>
</table>

## Reference

- [详解常见的三种分布式锁](https://zhuanlan.zhihu.com/p/651152250)
