---
title: "ZooKeeper 分布式锁"
sequence: "103"
---

## 节点类型

ZooKeeper 的树形数据存储结构是由 4 个节点构成的

- **持久节点**：默认的节点类型，一直存在于 ZooKeeper 中
- **持久顺序节点**：在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号
- **临时节点**：当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除
- **临时顺序节点**：按时间顺序编号的临时节点

## ZK 分布式锁相关基础知识

- ZK 一般由多个节点构成（单数），采用 ZAB 一致性协议。
  因此可以将 ZK 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。
- ZK 的数据以目录树的形式，每个目录称为 ZNode；ZNode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。
- 子节点有三种类型。
    - 序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。
    - 临时节点，一旦创建这个 ZNode 的客户端与服务器失去联系，这个 ZNode 也将自动删除。
    - 最后就是普通节点。
- Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。

## ZK 基本锁

原理：利用临时节点与 Watch 机制。
每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，
创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。

使用临时节点：

- 好处：当进程挂掉后能自动上锁的节点自动删除即取消锁。
- 缺点：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。

## 实现原理

- 当一个客户端想要获取锁时，它在 ZooKeeper 上创建一个有序的临时节点。
- 每个客户端创建的节点会按照顺序排列，形成一个有序的节点路径。客户端会监视前一个节点，一旦前一个节点被删除（代表锁被释放），该客户端就获得了锁。
- 如果某个客户端没有获得锁，它会监听自己创建的节点，并等待前一个节点被删除，从而触发自己获取锁的机会。
- 当客户端完成任务后，它会删除自己创建的临时节点，从而释放锁。

## 步骤

1.在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。
2.判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。
3.当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。
4.取锁成功则执行代码，最后释放锁（删除该节点）。

## 羊群效应

Zookeeper 实现分布式锁的羊群效应和解决方法

### 羊群效应

- 在整个分布式锁的竞争过程中，大量的「 Watcher 通知」和「子节点列表的获取」操作重复运行，
  并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑
- 这就会对 ZooKeeper 服务器造成巨大的性能影响和网络冲击。
  更甚的是，如果同一时间多个节点对应的客户端完成事务或事务中断引起节点消失，ZooKeeper 服务器就会在短时间内向其他客户端发送大量的事件通知

### 解决方法

- 在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点
- 每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。
- 若本进程对应的临时节点编号不是最小的，则继续判断
    - 若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁
    - 若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁

## 优缺点

## 优点

- 可靠性：ZooKeeper 是一个高可用的分布式协调服务，基于它的分布式锁具有较高的可靠性和稳定性。
- 顺序性：ZooKeeper 的有序临时节点保证了锁的获取顺序，避免了死锁和竞争问题。
- 避免死锁：在锁的持有者释放锁之前，其他节点无法获取锁，从而避免了死锁问题。
- 容错性：即使部分节点发生故障，其他节点仍然可以正常获取锁，保证了系统的稳定性。

### 缺点

- 性能：ZooKeeper 是一个中心化的协调服务，可能在高并发场景下成为性能瓶颈。
- 复杂性：ZooKeeper 的部署和维护相对复杂，需要一定的运维工作。
- 单点故障：尽管 ZooKeeper 本身是高可用的，但如果 ZooKeeper 集群出现问题，可能会影响到基于它的分布式锁。

有序临时节点的机制确保了获取锁的顺序，避免了循环等待，从而有效地避免了死锁问题。
因为任何一个客户端在释放锁之前都会删除自己的节点，从而触发下一个等待的客户端获取锁。

需要注意的是，这种机制虽然能够有效避免死锁，但也可能带来性能问题。
当某个客户端释放锁时，需要触发所有等待的客户端获取锁，可能会导致较多的网络通信和监听事件。
因此，在高并发情况下，需要综合考虑性能和锁的可靠性。

总的来说，基于 ZooKeeper 的分布式锁能够确保数据一致性和锁的可靠性，但需要权衡性能和复杂性。
在选择时，需要根据具体场景来决定是否使用该种锁机制。
