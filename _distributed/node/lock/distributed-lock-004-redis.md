---
title: "Redis 分布式锁"
sequence: "104"
---

实现分布式锁时，需要实现的两个基本方法：

- 获取锁
    - 互斥：确保只能有一个线程获取锁，
        - 第一种方式：`SETNX lock thread_id`
        - 第二种方式：`SET lock value NX EX 10`，其中 `NX` 是互斥，`EX` 是设置超时时间
- 释放锁
    - 手动释放：`DEL lock`
    - 超时释放：获取锁时，添加一个超时时间，`EXPIRE lock`

## 阻塞/非阻塞

阻塞/非阻塞：可以是阻塞式（等待锁释放）或非阻塞式（立即返回结果）

## 实现方式

在 Redis 中，常用的分布式锁实现包括：

- SETNX（阻塞式）： 使用 `SETNX` 命令可以实现一个基本的分布式锁。
    - 当键不存在时设置键的值，返回 `1`，表示成功；
    - 如果键已经存在（锁已被其他客户端持有），则返回 `0`，表示获取锁失败。
    - 这是一个阻塞式的实现，因为请求会在获取锁前等待。
- RedLock（阻塞式）： RedLock 是一个由多个 Redis 实例组成的分布式锁实现，它使用了多个 Redis 节点以提高锁的可靠性。
    - 它是阻塞式的，因为每个节点在尝试获取锁时会阻塞，直到获取锁或超时。
- Redisson（阻塞式和非阻塞式）： Redisson 是一个基于 Redis 的分布式锁库，提供了阻塞式和非阻塞式两种锁。
    - 阻塞式锁在获取锁失败时会阻塞等待，而非阻塞式锁则会立即返回获取失败的标识。
- 基于 Lua 脚本的锁（非阻塞式）：使用 Redis 的 Lua 脚本可以实现非阻塞式的分布式锁。脚本尝试获取锁，并在获取失败时返回获取失败的标识。

## 续期

分布式锁，是否需要锁续期，取决于具体的实现和使用场景。
在使用分布式锁时，考虑业务逻辑的性质、执行时间，以及对锁的使用方式，从而决定是否需要设置锁续期。
续期可以提高锁的安全性，但也需要注意避免续期时间过长导致锁的长时间占用，影响其他操作。

### 续期

需要锁续期的情况：

长时间任务： 如果获取分布式锁的业务逻辑较为复杂或耗时，那么可能需要设置锁续期，以防止持有锁的客户端在执行业务逻辑时由于各种原因无法及时释放锁。
业务处理时间不确定： 如果业务处理时间不确定，无法预测锁会持有多长时间，那么设置锁续期可以确保在业务逻辑执行期间锁不会过早地被释放。

### 不续期

不需要锁续期的情况：

短时间任务： 如果获取分布式锁的业务逻辑非常简单且耗时很短，可以在执行完业务逻辑后立即释放锁，不需要设置锁续期。
业务逻辑可控： 如果业务逻辑可以控制在一个较短的时间内完成，且不会出现无法释放锁的情况，也可能不需要设置锁续期。

1、选用 Redis 实现分布式锁原因：

（1）Redis 有很高的性能；

（2）Redis 命令对此支持较好，实现起来比较方便

## 基于 REDIS 的 SETNX()、EXPIRE() 方法做分布式锁

setnx()

setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key
成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。

expire()

expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。

del(key)

delete key：删除 key

使用步骤

1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功

2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。

3、执行完业务代码后，可以通过 delete 命令删除 key。

加锁：使用 setnx key value 命令，如果 key 不存在，设置 value(加锁成功)。如果已经存在 lock(也就是有客户端持有锁了)
，则设置失败(加锁失败)。

解锁：使用 del 命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过 setnx 命令进行加锁。
key 的值可以根据业务设置，比如是用户中心使用的，可以命令为 USER_REDIS_LOCK，value 可以使用 uuid
保证唯一，用于标识加锁的客户端。保证加锁和解锁都是同一个客户端。

## 使用单命令 +Lua 脚本：

加锁改进：set lock_key unique_value NX PX 10000
释放锁改进：lua 脚本
这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。比如，如果在第一步 setnx
执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用
redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。

优缺点：
优势
性能更好。数据被存放在内存，而不是磁盘，避免了频繁的 IO 操作
很多缓存可以跨集群部署，避免了单点故障
很多缓存服务都提供了可以用来实现分布式锁的方法，比如 Redis 的 setnx 方法等
可以直接设置超时时间来控制锁的释放，因为这些缓存服务器一般支持自动删除过期数据
不足
通过超时时间来控制锁的失效时间，并不是十分靠谱，因为一个进程执行时间可能比较长，或受系统进程做内存回收等影响，导致时间超时，从而不正确地释放了锁

## 基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁

这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。

getset()

这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key
原来是不存在的，那么多次执行这个命令，会出现下边的效果：

getset(key, “value1”) 返回 null 此时 key 的值会被设置为 value1
getset(key, “value2”) 返回 value1 此时 key 的值会被设置为 value2
依次类推！
使用步骤

setnx(lockkey, 当前时间 + 过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。
get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向
3。
计算 newExpireTime = 当前时间 + 过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值
currentExpireTime。
判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset
设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行
delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。

## Reference

- [Redis实现分布式锁的7种方案，及正确使用姿势](https://www.cnblogs.com/wangyingshuo/p/14510524.html)
