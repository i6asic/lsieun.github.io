---
title: "MySQL 分布式锁"
sequence: "102"
---

## 基于乐观锁

### 基于表主键唯一做分布式锁

思路：利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可

上面这种简单的实现有以下几个问题：

这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。
这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。
在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。
当然，我们也可以有其他方式解决上面的问题。

数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上。
没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。
非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。
非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。但是这样是很消耗性能的，增加数据库压力。
非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。
比较好的办法是在程序中生产主键进行防重。
基于表字段版本号做分布式锁
这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。

## 基于悲观锁

### 基于数据库排他锁做分布式锁

在查询语句后面增加 for update，数据库会在查询过程中给数据库表增加排他锁 (注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。)。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。

我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过 connection.commit()操作来释放锁。

这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。

阻塞锁？ for update 语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。
锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。
但是还是无法直接解决数据库单点和可重入问题。

这里还可能存在另外一个问题，虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。

还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。

## 小结

- 悲观锁（Pessimistic Locking）： 悲观锁基于数据库的排他锁机制，即在获取锁时直接对数据库记录进行锁定，防止其他事务修改。在实现中，可以使用数据库支持的锁语句，如 SELECT ... FOR UPDATE。当事务想要获取锁时，会阻塞其他事务对同一行记录的修改，从而实现锁的效果。
- 乐观锁（Optimistic Locking）： 乐观锁通过记录版本号或时间戳来实现。在获取锁前，先读取记录的版本号或时间戳，然后在修改时检查是否与之前读取的值相同，如果相同则表示没有其他事务干扰，可以执行更新操作。如果不同，则说明其他事务已经修改了记录，需要处理冲突。
- 数据库表锁： 可以使用数据库的表级锁来实现分布式锁。在获取锁时，可以在某个特定的表中插入一条特殊的记录，表示锁已被持有。其他事务在获取锁时会检查表中是否存在这条记录，如果存在则表示锁已被占用。
- 数据库行锁： 类似于表锁，但是锁定的是表中的特定行记录。在获取锁时，可以锁定某一行记录，防止其他事务修改这一行。


### 优缺点

优点：

- 持久性锁： 数据库锁是持久性的，即使系统发生故障也不容易丢失锁，能够确保锁的可靠性。
- 数据一致性： 基于数据库的锁可以借助数据库事务来保证数据一致性，避免脏数据问题。
- 容易实现： 简单，易于理解，易于实现。
- 锁的粒度控制： 可以通过数据库的事务来控制锁的粒度，灵活地控制锁的范围。

缺点：

- 死锁：数据库锁没有失效时间，未获得锁的进程只能一直等待已获得锁的进程主动释 放锁。一旦已获得锁的进程挂掉或者解锁操作失败，会导致锁记录一直存在数据库中，其它进程无法获得锁
- 性能差： 数据库操作通常相对较慢，基于数据库的分布式锁可能会影响性能，尤其在高并发场景下。
- 单点故障： 如果使用单个数据库作为锁服务，那么数据库成为了单点故障，可能影响整个系统的可用性。
- 数据库连接开销： 基于数据库的锁可能需要频繁地获取和释放数据库连接，增加了数据库连接的开销。
- 复杂性： 虽然基于数据库的锁相对易于理解，但在高并发和分布式环境中，需要处理事务隔离级别、锁的超时等问题，可能会增加实现的复杂性。

## Reference

- [详解常见的三种分布式锁](https://zhuanlan.zhihu.com/p/651152250)

