<html lang="zh">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Chapter 2. The Structure of the Java Virtual Machine</title>
    <link rel="stylesheet" type="text/css" href="../res/javaspec.css"/>
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div id="logo">
    <img src="../res/oralogo_small.gif" alt="Oracle Logo"/><br/>
    <p>
        <a href="https://docs.oracle.com/en/java/javase/21/">Java SE</a> &gt;
        <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt;
        <a href="./index.html">Java Virtual Machine Specification</a>
    </p>
</div>
<div class="navheader">
    <table width="100%" summary="Navigation header">
        <tbody>
        <tr>
            <th colspan="3" align="center">Chapter 2. The Structure of the Java Virtual Machine</th>
        </tr>
        <tr>
            <td width="20%" align="left"><a accesskey="p"
                                            href="./jvms-1.html">Prev</a>
            </td>
            <th width="60%" align="center"></th>
            <td width="20%" align="right"><a accesskey="n"
                                             href="./jvms-3.html">Next</a></td>
        </tr>
        </tbody>
    </table>
    <hr/>
</div>
<div lang="en" class="chapter">
    <div class="titlepage">
        <div>
            <div>
                <h1 class="title"><a id="jvms-2"></a>Chapter 2. The Structure of the Java Virtual Machine
                </h1>
            </div>
        </div>
    </div>
    <div class="toc">
        <p><b>Table of Contents</b></p>
        <dl class="toc">
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.1">2.1. The <code
                    class="literal">class</code> File Format</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.2">2.2. Data
                     Types</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.3">2.3. Primitive
                     Types and Values</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.3.1">2.3.1.
                           Integral Types and Values</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.3.2">2.3.2.
                           Floating-Point Types and Values</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.3.3">2.3.3. The
                           <code class="literal">returnAddress</code> Type and Values</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.3.4">2.3.4. The
                           <code class="literal">boolean</code> Type</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.4">2.4. Reference
                     Types and Values</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.5">2.5. Run-Time Data
                     Areas</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.1">2.5.1. The
                           <code class="literal">pc</code> Register</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.2">2.5.2. Java
                           Virtual Machine Stacks</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.3">2.5.3.
                           Heap</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.4">2.5.4.
                           Method Area</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.5">2.5.5.
                           Run-Time Constant Pool</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.5.6">2.5.6.
                           Native Method Stacks</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.6">2.6.
                     Frames</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.6.1">2.6.1.
                           Local Variables</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.6.2">2.6.2.
                           Operand Stacks</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.6.3">2.6.3.
                           Dynamic Linking</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.6.4">2.6.4.
                           Normal Method Invocation Completion</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.6.5">2.6.5.
                           Abrupt Method Invocation Completion</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.7">2.7. Representation
                     of Objects</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.8">2.8. Floating-Point
                     Arithmetic</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.9">2.9. Special
                     Methods</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.9.1">2.9.1.
                           Instance Initialization Methods</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.9.2">2.9.2.
                           Class Initialization Methods</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.9.3">2.9.3.
                           Signature Polymorphic Methods</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.10">2.10.
                     Exceptions</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.11">2.11. Instruction
                     Set Summary</a></span></dt>
            <dd>
                <dl>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.1">2.11.1.
                           Types and the Java Virtual Machine</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.2">2.11.2.
                           Load and Store Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.3">2.11.3.
                           Arithmetic Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.4">2.11.4.
                           Type Conversion Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.5">2.11.5.
                           Object Creation and Manipulation</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.6">2.11.6.
                           Operand Stack Management Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.7">2.11.7.
                           Control Transfer Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.8">2.11.8.
                           Method Invocation and Return Instructions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.9">2.11.9.
                           Throwing Exceptions</a></span></dt>
                    <dt><span class="section"><a
                            href="./jvms-2.html#jvms-2.11.10">2.11.10.
                           Synchronization</a></span></dt>
                </dl>
            </dd>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.12">2.12. Class
                     Libraries</a></span></dt>
            <dt><span class="section"><a
                    href="./jvms-2.html#jvms-2.13">2.13. Public
                     Design, Private Implementation</a></span></dt>
        </dl>
    </div>
    <p class="norm"><a id="jvms-2-100"></a>This document specifies an
        abstract machine. It does not describe any particular implementation
        of the Java Virtual Machine.
    </p>
    <p class="norm"><a id="jvms-2-110"></a>To implement the Java Virtual Machine
        correctly, you need only be able to read the <code class="literal">class</code> file format and
        correctly perform the operations specified therein. Implementation
        details that are not part of the Java Virtual Machine's specification would
        unnecessarily constrain the creativity of implementors. For example,
        the memory layout of run-time data areas, the garbage-collection
        algorithm used, and any internal optimization of the Java Virtual Machine
        instructions (for example, translating them into machine code) are
        left to the discretion of the implementor.
    </p>
    <p class="norm"><a id="jvms-2-120"></a>
        All references to Unicode in this specification are given with respect
        to <em class="citetitle">The Unicode Standard, Version 15.0</em>, available
        at <a class="link" href="https://www.unicode.org/" target="_top"><code
                class="uri">https://www.unicode.org/</code></a>.
    </p>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.1"></a>2.1. The <code
                            class="literal">class</code> File Format
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.1-100"></a>Compiled code to be executed
            by the Java Virtual Machine is represented using a hardware- and operating
            system-independent binary format, typically (but not necessarily)
            stored in a file, known as the <code class="literal">class</code> file format. The <code
                    class="literal">class</code> file
            format precisely defines the representation of a class or interface,
            including details such as byte ordering that might be taken for
            granted in a platform-specific object file format.
        </p>
        <p class="norm"><a id="jvms-2.1-110"></a>Chapter 4, "The <code class="literal">class</code> File
            Format", covers the <code class="literal">class</code> file format in detail.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.2"></a>2.2. Data Types
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.2-100"></a>Like the Java programming language, the Java Virtual Machine
            operates on two kinds of types: <span class="emphasis"><em>primitive types</em></span>
            and <span class="emphasis"><em>reference types</em></span>. There are, correspondingly,
            two kinds of values that can be stored in variables, passed as
            arguments, returned by methods, and operated upon: <span class="emphasis"><em>primitive
                  values</em></span> and <span class="emphasis"><em>reference values</em></span>.
        </p>
        <p class="norm"><a id="jvms-2.2-110"></a>The Java Virtual Machine expects that nearly
            all type checking is done prior to run time, typically by a compiler,
            and does not have to be done by the Java Virtual Machine itself. Values of primitive
            types need not be tagged or otherwise be inspectable to determine
            their types at run time, or to be distinguished from values of
            reference types. Instead, the instruction set of the Java Virtual Machine
            distinguishes its operand types using instructions intended to operate
            on values of specific types. For instance, <span class="emphasis"><em>iadd</em></span>, <span
                    class="emphasis"><em>ladd</em></span>, <span class="emphasis"><em>fadd</em></span>, and
            <span class="emphasis"><em>dadd</em></span> are all Java Virtual Machine instructions that add two numeric
            values and
            produce numeric results, but each is specialized for its operand type:
            <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and
            <code class="literal">double</code>, respectively. For a summary of
            type support in the Java Virtual Machine instruction set, see
            <a class="xref" href="./jvms-2.html#jvms-2.11.1"
               title="2.11.1. Types and the Java Virtual Machine">2.11.1</a>.
        </p>
        <p class="norm"><a id="jvms-2.2-120"></a>The Java Virtual Machine contains explicit
            support for objects. An object is either a dynamically allocated class
            instance or an array. A reference to an object is considered to have
            Java Virtual Machine type <code class="literal">reference</code>. Values of type <code
                    class="literal">reference</code> can be thought of as pointers
            to objects. More than one reference to an object may exist. Objects
            are always operated on, passed, and tested via values of type
            <code class="literal">reference</code>.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.3"></a>2.3. Primitive Types and Values
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.3-100"></a>
            The primitive data types supported by the Java Virtual Machine are the
            <span class="emphasis"><em>numeric types</em></span>, the <code class="literal">boolean</code> type (<a
                    class="xref" href="./jvms-2.html#jvms-2.3.4"
                    title="2.3.4. The boolean Type">2.3.4</a>), and the <code class="literal">returnAddress</code> type
            (<a
                    class="xref" href="./jvms-2.html#jvms-2.3.3"
                    title="2.3.3. The returnAddress Type and Values">2.3.3</a>).
        </p>
        <p class="norm"><a id="jvms-2.3-110"></a>
            The numeric types consist of the <span class="emphasis"><em>integral types</em></span>
            (<a class="xref" href="./jvms-2.html#jvms-2.3.1"
                title="2.3.1. Integral Types and Values">2.3.1</a>) and the <span class="emphasis"><em>floating-point
                  types</em></span> (<a class="xref"
                                        href="./jvms-2.html#jvms-2.3.2"
                                        title="2.3.2. Floating-Point Types and Values">2.3.2</a>).
        </p>
        <p class="norm"><a id="jvms-2.3-120"></a>
            The integral types are:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-120-A"></a>
                        <code class="literal">byte</code>, whose values are 8-bit signed two's-complement integers,
                        and whose default value is zero
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-120-B"></a>
                        <code class="literal">short</code>, whose values are 16-bit signed two's-complement integers,
                        and whose default value is zero
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-120-C"></a>
                        <code class="literal">int</code>, whose values are 32-bit signed two's-complement integers,
                        and whose default value is zero
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-120-D"></a>
                        <code class="literal">long</code>, whose values are 64-bit signed two's-complement integers,
                        and whose default value is zero
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-120-E"></a>
                        <code class="literal">char</code>, whose values are 16-bit unsigned integers representing
                        Unicode code points in the Basic Multilingual Plane, encoded with
                        UTF-16, and whose default value is the null code point
                        (<code class="literal">'\u0000'</code>)
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.3-130"></a>
            The floating-point types are:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-130-A"></a>
                        <code class="literal">float</code>, whose values
                        exactly correspond to the values representable in the 32-bit
                        IEEE 754 binary32 format, and whose default value is positive
                        zero
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.3-130-B"></a>
                        <code class="literal">double</code>, whose values
                        exactly correspond to the values of the 64-bit IEEE 754
                        binary64 format, and whose default value is positive
                        zero
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.3-200"></a>
            The values of the <code class="literal">boolean</code> type encode the truth values <code
                    class="literal">true</code> and
            <code class="literal">false</code>, and the default value is <code class="literal">false</code>.
        </p>
        <p class="note">The First Edition of <em class="citetitle">The <span class="trademark">Java</span> Virtual
            Machine Specification</em> did not consider
            <code class="literal">boolean</code> to be a Java Virtual Machine type. However, <code
                    class="literal">boolean</code> values do have
            limited support in the Java Virtual Machine. The Second Edition of <em class="citetitle">The <span
                    class="trademark">Java</span> Virtual Machine Specification</em>
            clarified the issue by treating <code class="literal">boolean</code> as a type.
        </p>
        <p class="norm"><a id="jvms-2.3-300"></a>
            The values of the <code class="literal">returnAddress</code> type are pointers to the opcodes of
            Java Virtual Machine instructions. Of the primitive types, only the <code
                    class="literal">returnAddress</code> type
            is not directly associated with a Java programming language type.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.3.1"></a>2.3.1. Integral Types and Values
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.3.1-100"></a>The values of the integral
                types of the Java Virtual Machine are:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.3.1-100-A"></a>For <code class="literal">byte</code>, from -128
                            to 127 (-2<sup>7</sup> to
                            2<sup>7</sup> - 1), inclusive
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.3.1-100-B"></a>For <code class="literal">short</code>, from
                            -32768 to 32767 (-2<sup>15</sup> to
                            2<sup>15</sup> - 1), inclusive
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.3.1-100-C"></a>For <code class="literal">int</code>, from
                            -2147483648 to 2147483647 (-2<sup>31</sup> to
                            2<sup>31</sup> - 1), inclusive
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.3.1-100-D"></a>For <code class="literal">long</code>, from
                            -9223372036854775808 to 9223372036854775807
                            (-2<sup>63</sup> to 2<sup>63</sup>
                            - 1), inclusive
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.3.1-100-E"></a>For <code class="literal">char</code>, from 0 to
                            65535 inclusive
                        </p>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.3.2"></a>2.3.2. Floating-Point Types and Values
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm-dynamic"><a id="jvms-2.3.2-100"></a>
                The floating-point types are <code class="literal">float</code> and <code class="literal">double</code>,
                which are
                conceptually associated with the 32-bit binary32 and 64-bit binary64
                floating-point formats for IEEE 754 values and operations, as
                specified in the IEEE 754 Standard (JLS 1.7).
            </p>
            <p class="note">
                In Java SE 15 and later, the Java Virtual Machine uses the 2019 version of the
                IEEE 754 Standard. Prior to Java SE 15, the Java Virtual Machine used the 1985
                version of the IEEE 754 Standard, where the binary32 format was known
                as the single format and the binary64 format was known as the
                double format.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-110"></a>
                IEEE 754 includes not only positive and negative numbers
                that consist of a sign and magnitude, but also positive and negative
                zeros, positive and negative <span class="emphasis"><em>infinities</em></span>, and
                special <span class="emphasis"><em>Not-a-Number</em></span> values (hereafter
                abbreviated NaN). A NaN value is used to represent the result of
                certain invalid operations such as dividing zero by zero. NaN
                constants of both <code class="literal">float</code> and <code class="literal">double</code> type are
                predefined as
                <code class="literal">Float.NaN</code> and <code class="literal">Double.NaN</code>.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-120"></a>
                The finite nonzero values of a floating-point type can all
                be expressed in the form
                <span class="emphasis"><em>s</em></span> <span class="symbol">&#8901;</span> <span
                        class="emphasis"><em>m</em></span> <span class="symbol">&#8901;</span> 2<sup>(<span
                        class="emphasis"><em>e</em></span> - <code class="varname">N</code> + 1)</sup>,
                where:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-dynamic"><a id="jvms-2.3.2-120-A"></a>
                            <span class="emphasis"><em>s</em></span> is +1 or -1,
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-dynamic"><a id="jvms-2.3.2-120-B"></a>
                            <span class="emphasis"><em>m</em></span> is a positive integer less than 2<sup><code
                                    class="varname">N</code></sup>,

                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-dynamic"><a id="jvms-2.3.2-120-C"></a>
                            <span class="emphasis"><em>e</em></span> is an integer between
                            <span class="emphasis"><em>E<sub>min</sub></em></span> = -(2<sup><span
                                    class="type">K</span>-1</sup>-2) and
                            <span class="emphasis"><em>E<sub>max</sub></em></span> = 2<sup><span
                                    class="type">K</span>-1</sup>-1, inclusive, and
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-dynamic"><a id="jvms-2.3.2-120-D"></a>
                            <code class="varname">N</code> and <span class="type">K</span> are parameters that depend on
                            the
                            type.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm-dynamic"><a id="jvms-2.3.2-130"></a>
                Some values can be represented in this form in more than one way. For
                example, supposing that a value <code class="varname">v</code> of a floating-point type might be
                represented in this form using certain values for <span class="emphasis"><em>s</em></span>, <span
                        class="emphasis"><em>m</em></span>, and
                <span class="emphasis"><em>e</em></span>, then if it happened that <span
                        class="emphasis"><em>m</em></span> were even and <span class="emphasis"><em>e</em></span> were
                less
                than 2<sup><span class="type">K</span>-1</sup>, one could halve <span class="emphasis"><em>m</em></span>
                and
                increase <span class="emphasis"><em>e</em></span> by 1 to produce a second representation for the same
                value <code class="varname">v</code>.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-140"></a>
                A representation in this form is called
                <span class="emphasis"><em>normalized</em></span> if <span class="emphasis"><em>m</em></span> <span
                        class="symbol">&#8805;</span>
                2<sup><code class="varname">N</code>-1</sup>; otherwise the representation is
                said to be <span class="emphasis"><em>subnormal</em></span>. If a value of a
                floating-point type cannot be represented in such a way that <span class="emphasis"><em>m</em></span>
                <span class="symbol">&#8805;</span> 2<sup><code class="varname">N</code>-1</sup>, then the value is said
                to be
                a <span class="emphasis"><em>subnormal value</em></span>, because its magnitude is below
                the magnitude of the smallest normalized value.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-150"></a>
                The constraints on the parameters <code class="varname">N</code> and <span class="type">K</span> (and on
                the derived
                parameters <span class="emphasis"><em>E<sub>min</sub></em></span> and <span
                        class="emphasis"><em>E<sub>max</sub></em></span>) for <code class="literal">float</code> and
                <code
                        class="literal">double</code> are summarized
                in <a class="xref"
                      href="./jvms-2.html#jvms-2.3.2-150-A"
                      title="Table 2.3.2-A. Floating-point parameters">Table 2.3.2-A</a>.
            </p>
            <div class="table"><a id="jvms-2.3.2-150-A"></a>
                <p class="title"><b>Table 2.3.2-A. Floating-point parameters</b></p>
                <div class="table-contents">
                    <table class="table" summary="Floating-point parameters" border="1">
                        <colgroup>
                            <col/>
                            <col/>
                            <col/>
                        </colgroup>
                        <thead>
                        <tr>
                            <th>Parameter</th>
                            <th><code class="literal">float</code></th>
                            <th><code class="literal">double</code></th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td><code class="varname">N</code></td>
                            <td>24</td>
                            <td>53</td>
                        </tr>
                        <tr>
                            <td><span class="type">K</span></td>
                            <td>8</td>
                            <td>11</td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>E<sub>max</sub></em></span></td>
                            <td>+127</td>
                            <td>+1023</td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>E<sub>min</sub></em></span></td>
                            <td>-126</td>
                            <td>-1022</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <br class="table-break"/>
            <p class="norm-dynamic"><a id="jvms-2.3.2-200"></a>
                Except for NaN, floating-point values are <span class="emphasis"><em>ordered</em></span>.
                When arranged from smallest to largest, they are negative infinity, negative
                finite nonzero values, positive and negative zero, positive finite
                nonzero values, and positive infinity.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-210"></a>
                IEEE 754 allows multiple distinct NaN values for each of its
                binary32 and binary64 floating-point formats. However, the
                Java SE Platform generally treats NaN values of a given floating-point type
                as though collapsed into a single canonical value, and hence this
                specification normally refers to an arbitrary NaN as though to a
                canonical value.
            </p>
            <p class="note">Under IEEE 754, a floating-point operation with
                non-NaN arguments may generate a NaN result. IEEE 754 specifies a set
                of NaN bit patterns, but does not mandate which particular NaN bit
                pattern is used to represent a NaN result; this is left to the
                hardware architecture. A programmer can create NaNs with different bit
                patterns to encode, for example, retrospective diagnostic
                information. These NaN values can be created with the
                <code class="literal">Float.intBitsToFloat</code> and
                <code class="literal">Double.longBitsToDouble</code> methods for <code class="literal">float</code> and
                <code class="literal">double</code>, respectively. Conversely, to inspect the bit patterns of NaN
                values, the <code class="literal">Float.floatToRawIntBits</code> and
                <code class="literal">Double.doubleToRawLongBits</code> methods can be used for
                <code class="literal">float</code> and <code class="literal">double</code>, respectively.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-220"></a>
                Positive zero and negative zero compare equal, but there are other
                operations that can distinguish them; for example, dividing
                <code class="literal">1.0</code> by <code class="literal">0.0</code> produces positive
                infinity, but dividing <code class="literal">1.0</code> by
                <code class="literal">-0.0</code> produces negative infinity.
            </p>
            <p class="norm-dynamic"><a id="jvms-2.3.2-230"></a>
                NaN is <span class="emphasis"><em>unordered</em></span>, so numerical comparisons and tests
                for numerical equality have the value <code class="literal">false</code> if either or both of
                their operands are NaN. In particular, a test for numerical equality
                of a value against itself has the value <code class="literal">false</code> if and only if the
                value is NaN. A test for numerical inequality has the value <code class="literal">true</code> if
                either operand is NaN.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.3.3"></a>2.3.3. The <code
                                class="literal">returnAddress</code> Type and Values
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.3.3-100"></a>The <code class="literal">returnAddress</code> type is
                used by the Java Virtual Machine's <span class="emphasis"><em>jsr</em></span>, <span
                        class="emphasis"><em>ret</em></span>, and <span class="emphasis"><em>jsr_w</em></span>
                instructions
                (<a class="xref" href="./jvms-6.html#jvms-6.5.jsr"
                    title="jsr"><span class="emphasis"><em>jsr</em></span></a>, <a class="xref"
                                                                                   href="./jvms-6.html#jvms-6.5.ret"
                                                                                   title="ret"><span
                        class="emphasis"><em>ret</em></span></a>,
                <a class="xref" href="./jvms-6.html#jvms-6.5.jsr_w"
                   title="jsr_w"><span class="emphasis"><em>jsr_w</em></span></a>). The values of the <code
                        class="literal">returnAddress</code>
                type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the
                numeric primitive types, the <code class="literal">returnAddress</code> type does not correspond
                to any Java programming language type and cannot be modified by the running
                program.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.3.4"></a>2.3.4. The <code class="literal">boolean</code>
                            Type
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.3.4-100"></a>Although the Java Virtual Machine defines a
                <code class="literal">boolean</code> type, it only provides very limited support for it. There
                are no Java Virtual Machine instructions solely dedicated to operations on <code
                        class="literal">boolean</code>
                values. Instead, expressions in the Java programming language that operate on
                <code class="literal">boolean</code> values are compiled to use values of the Java Virtual Machine <code
                        class="literal">int</code> data
                type.
            </p>
            <p class="norm"><a id="jvms-2.3.4-200"></a>The Java Virtual Machine does directly
                support <code class="literal">boolean</code> arrays. Its <span class="emphasis"><em>newarray</em></span>
                instruction
                (<a class="xref" href="./jvms-6.html#jvms-6.5.newarray"
                    title="newarray"><span class="emphasis"><em>newarray</em></span></a>) enables creation of <code
                        class="literal">boolean</code>
                arrays. Arrays of type <code class="literal">boolean</code> are accessed and modified using the
                <code class="literal">byte</code> array instructions <span class="emphasis"><em>baload</em></span> and
                <span class="emphasis"><em>bastore</em></span>
                (<a class="xref" href="./jvms-6.html#jvms-6.5.baload"
                    title="baload"><span class="emphasis"><em>baload</em></span></a>,
                <a class="xref" href="./jvms-6.html#jvms-6.5.bastore"
                   title="bastore"><span class="emphasis"><em>bastore</em></span></a>).
            </p>
            <p class="note">In Oracles Java Virtual Machine implementation, <code class="literal">boolean</code> arrays
                in the Java programming language are encoded as Java Virtual Machine <code class="literal">byte</code>
                arrays, using 8 bits per
                <code class="literal">boolean</code> element.
            </p>
            <p class="norm"><a id="jvms-2.3.4-210"></a>The Java Virtual Machine encodes <code
                    class="literal">boolean</code>
                array components using <code class="literal">1</code> to represent <code class="literal">true</code> and
                <code class="literal">0</code> to
                represent <code class="literal">false</code>. Where Java programming language <code
                        class="literal">boolean</code> values are mapped by
                compilers to values of Java Virtual Machine type <code class="literal">int</code>, the compilers must
                use
                the
                same encoding.
            </p>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.4"></a>2.4. Reference Types and Values
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.4-100"></a>There are three kinds of <code class="literal">reference</code>
            types: class types, array types, and interface types. Their values are
            references to dynamically created class instances, arrays, or class
            instances or arrays that implement interfaces, respectively.
        </p>
        <p class="norm"><a id="jvms-2.4-110"></a>An array type consists of a
            <span class="emphasis"><em>component type</em></span> with a single dimension (whose
            length is not given by the type). The component type of an array type
            may itself be an array type. If, starting from any array type, one
            considers its component type, and then (if that is also an array type)
            the component type of that type, and so on, eventually one must reach
            a component type that is not an array type; this is called
            the <span class="emphasis"><em>element type</em></span> of the array type. The element
            type of an array type is necessarily either a primitive type, or a
            class type, or an interface type.
        </p>
        <p class="norm"><a id="jvms-2.4-200"></a>A <code class="literal">reference</code> value may also be the
            special null reference, a reference to no object, which will be
            denoted here by <code class="literal">null</code>. The <code class="literal">null</code> reference initially
            has no run-time
            type, but may be cast to any type. The default value of a <code class="literal">reference</code> type
            is <code class="literal">null</code>.
        </p>
        <p class="norm"><a id="jvms-2.4-300"></a>This specification does not
            mandate a concrete value encoding <code class="literal">null</code>.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.5"></a>2.5. Run-Time Data Areas
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.5-100"></a>The Java Virtual Machine defines various
            run-time data areas that are used during execution of a program. Some
            of these data areas are created on Java Virtual Machine start-up and are destroyed
            only when the Java Virtual Machine terminates. Other data areas are per thread. Per-thread
            data areas are created when a thread is created and destroyed when the
            thread terminates.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.1"></a>2.5.1. The <code class="literal">pc</code> Register
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.1-100"></a>The Java Virtual Machine can support many
                threads of execution at once (JLS 17). Each Java Virtual Machine thread has its own
                <code class="literal">pc</code> (program counter) register. At any point, each Java Virtual Machine
                thread is
                executing the code of a single method, namely the current method
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>) for that thread. If that method is not
                <code class="literal">native</code>, the <code class="literal">pc</code> register contains the address
                of
                the Java Virtual Machine
                instruction currently being executed. If the method currently being
                executed by the thread is <code class="literal">native</code>, the value of the Java Virtual Machine's
                <code class="literal">pc</code>
                register is undefined. The Java Virtual Machine's <code class="literal">pc</code> register is wide
                enough
                to
                hold a <code class="literal">returnAddress</code> or a native pointer on the specific
                platform.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.2"></a>2.5.2. Java Virtual Machine Stacks
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.2-100"></a>Each Java Virtual Machine thread has a
                private <span class="emphasis"><em>Java Virtual Machine stack</em></span>, created at the same time as
                the thread. A Java Virtual Machine stack stores frames
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>). A Java Virtual Machine stack is analogous to the stack
                of a conventional language such as C: it holds local variables and
                partial results, and plays a part in method invocation and
                return. Because the Java Virtual Machine stack is never manipulated directly except
                to push and pop frames, frames may be heap allocated. The memory for a
                Java Virtual Machine stack does not need to be contiguous.
            </p>
            <p class="note">In the First Edition of <em class="citetitle">The <span class="trademark">Java</span>
                Virtual Machine Specification</em>, the Java Virtual Machine stack
                was known as the <span class="emphasis"><em>Java stack</em></span>.
            </p>
            <p class="norm"><a id="jvms-2.5.2-110"></a>This specification permits
                Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and
                contract as required by the computation. If the Java Virtual Machine stacks are of a
                fixed size, the size of each Java Virtual Machine stack may be chosen independently
                when that stack is created.
            </p>
            <p class="note">A Java Virtual Machine implementation may provide the programmer or
                the user control over the initial size of Java Virtual Machine stacks, as well as, in
                the case of dynamically expanding or contracting Java Virtual Machine stacks, control
                over the maximum and minimum sizes.
            </p>
            <p class="norm"><a id="jvms-2.5.2-200"></a>The following exceptional
                conditions are associated with Java Virtual Machine stacks:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.2-200-A"></a>If
                            the computation in a thread requires a larger Java Virtual Machine stack than is
                            permitted, the Java Virtual Machine throws a <code class="literal">StackOverflowError</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.2-200-B"></a>If
                            Java Virtual Machine stacks can be dynamically expanded, and expansion is
                            attempted but insufficient memory can be made available to effect
                            the expansion, or if insufficient memory can be made available to
                            create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine
                            throws
                            an <code class="literal">OutOfMemoryError</code>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.3"></a>2.5.3. Heap
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.3-100"></a>The Java Virtual Machine has
                a <span class="emphasis"><em>heap</em></span> that is shared among all Java Virtual Machine
                threads. The heap is the run-time data area from which memory for all
                class instances and arrays is allocated.
            </p>
            <p class="norm"><a id="jvms-2.5.3-110"></a>The heap is created on
                virtual machine start-up. Heap storage for objects is reclaimed by an
                automatic storage management system (known as a <span class="emphasis"><em>garbage
                     collector</em></span>); objects are never explicitly deallocated. The
                Java Virtual Machine assumes no particular type of automatic storage management
                system, and the storage management technique may be chosen according
                to the implementor's system requirements. The heap may be of a fixed
                size or may be expanded as required by the computation and may be
                contracted if a larger heap becomes unnecessary. The memory for the
                heap does not need to be contiguous.
            </p>
            <p class="note">A Java Virtual Machine implementation may provide the programmer or
                the user control over the initial size of the heap, as well as, if the
                heap can be dynamically expanded or contracted, control over the
                maximum and minimum heap size.
            </p>
            <p class="norm"><a id="jvms-2.5.3-200"></a>The following exceptional
                condition is associated with the heap:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.3-200-A"></a>If a
                            computation requires more heap than can be made available by the
                            automatic storage management system, the Java Virtual Machine throws an
                            <code class="literal">OutOfMemoryError</code>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.4"></a>2.5.4. Method Area
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.4-100"></a>The Java Virtual Machine has
                a <span class="emphasis"><em>method area</em></span> that is shared among all Java Virtual Machine
                threads. The method area is analogous to the storage area for compiled
                code of a conventional language or analogous to the "text" segment in
                an operating system process. It stores per-class structures such as
                the run-time constant pool, field and method data, and the code for
                methods and constructors, including the special methods used in class
                and interface initialization and in instance initialization
                (<a class="xref" href="./jvms-2.html#jvms-2.9"
                    title="2.9. Special Methods">2.9</a>).
            </p>
            <p class="norm"><a id="jvms-2.5.4-110"></a>The method area is created
                on virtual machine start-up. Although the method area is logically
                part of the heap, simple implementations may choose not to either
                garbage collect or compact it. This
                specification does not mandate the location of the method area or the
                policies used to manage compiled code. The method area may be of a
                fixed size or may be expanded as required by the computation and may
                be contracted if a larger method area becomes unnecessary. The memory
                for the method area does not need to be contiguous.
            </p>
            <p class="note">A Java Virtual Machine implementation may provide the programmer or
                the user control over the initial size of the method area, as well as,
                in the case of a varying-size method area, control over the maximum
                and minimum method area size.
            </p>
            <p class="norm"><a id="jvms-2.5.4-200"></a>The following exceptional
                condition is associated with the method area:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.4-200-A"></a>If
                            memory in the method area cannot be made available to satisfy an
                            allocation request, the Java Virtual Machine throws an <code
                                    class="literal">OutOfMemoryError</code>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.5"></a>2.5.5. Run-Time Constant Pool
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.5-100"></a>A <span class="emphasis"><em>run-time
                     constant pool</em></span> is a per-class or per-interface run-time
                representation of the <code class="literal">constant_pool</code> table in a <code
                        class="literal">class</code> file
                (<a class="xref" href="./jvms-4.html#jvms-4.4"
                    title="4.4. The Constant Pool">4.4</a>). It contains several kinds of constants,
                ranging from numeric literals known at compile-time to method and
                field references that must be resolved at run-time. The run-time
                constant pool serves a function similar to that of a symbol table for
                a conventional programming language, although it contains a wider
                range of data than a typical symbol table.
            </p>
            <p class="norm"><a id="jvms-2.5.5-110"></a>Each run-time constant pool
                is allocated from the Java Virtual Machine's method area
                (<a class="xref" href="./jvms-2.html#jvms-2.5.4"
                    title="2.5.4. Method Area">2.5.4</a>). The run-time constant pool for a class
                or interface is constructed when the class or interface is created
                (<a class="xref" href="./jvms-5.html#jvms-5.3"
                    title="5.3. Creation and Loading">5.3</a>) by the Java Virtual Machine.
            </p>
            <p class="norm"><a id="jvms-2.5.5-200"></a>The following exceptional
                condition is associated with the construction of the run-time constant
                pool for a class or interface:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.5-200-A"></a>When
                            creating a class or interface, if the construction of the run-time
                            constant pool requires more memory than can be made available in
                            the method area of the Java Virtual Machine, the Java Virtual Machine throws an <code
                                    class="literal">OutOfMemoryError</code>.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="note">See <a class="xref" href="./jvms-5.html"
                                   title="Chapter 5. Loading, Linking, and Initializing">5 (<i>Loading, Linking, and
                Initializing</i>)</a> for information about the
                construction of the run-time constant pool.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.5.6"></a>2.5.6. Native Method Stacks
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.5.6-100"></a>An implementation of the
                Java Virtual Machine may use conventional stacks, colloquially called "C stacks," to
                support <code class="literal">native</code> methods (methods written in a language other than the
                Java programming language). Native method stacks may also be used by the
                implementation of an interpreter for the Java Virtual Machine's instruction set in a
                language such as C. Java Virtual Machine implementations that cannot load <code
                        class="literal">native</code>
                methods and that do not themselves rely on conventional stacks need
                not supply native method stacks. If supplied, native method stacks are
                typically allocated per thread when each thread is created.
            </p>
            <p class="norm"><a id="jvms-2.5.6-110"></a>This specification permits
                native method stacks either to be of a fixed size or to dynamically
                expand and contract as required by the computation. If the native
                method stacks are of a fixed size, the size of each native method
                stack may be chosen independently when that stack is created.
            </p>
            <p class="note">A Java Virtual Machine implementation may provide the programmer or
                the user control over the initial size of the native method stacks, as
                well as, in the case of varying-size native method stacks, control
                over the maximum and minimum method stack sizes.
            </p>
            <p class="norm"><a id="jvms-2.5.6-200"></a>The following exceptional
                conditions are associated with native method stacks:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.6-200-A"></a>If
                            the computation in a thread requires a larger native method
                            stack than is permitted, the Java Virtual Machine throws a <code
                                    class="literal">StackOverflowError</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm-error"><a id="jvms-2.5.6-200-B"></a>If
                            native method stacks can be dynamically expanded and native method
                            stack expansion is attempted but insufficient memory can be made
                            available, or if insufficient memory can be made available to
                            create the initial native method stack for a new thread, the Java Virtual Machine
                            throws an <code class="literal">OutOfMemoryError</code>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.6"></a>2.6. Frames
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.6-100"></a>A <span class="emphasis"><em>frame</em></span>
            is used to store data and partial results, as well as to perform
            dynamic linking, return values for methods, and dispatch
            exceptions.
        </p>
        <p class="norm"><a id="jvms-2.6-110"></a>A new frame is created each
            time a method is invoked. A frame is destroyed when its method
            invocation completes, whether that completion is normal or abrupt (it
            throws an uncaught exception). Frames are allocated from the Java Virtual Machine
            stack (<a class="xref" href="./jvms-2.html#jvms-2.5.2"
                      title="2.5.2. Java Virtual Machine Stacks">2.5.2</a>) of the thread creating the
            frame. Each frame has its own array of local variables
            (<a class="xref" href="./jvms-2.html#jvms-2.6.1"
                title="2.6.1. Local Variables">2.6.1</a>), its own operand stack
            (<a class="xref" href="./jvms-2.html#jvms-2.6.2"
                title="2.6.2. Operand Stacks">2.6.2</a>), and a reference to the run-time
            constant pool (<a class="xref"
                              href="./jvms-2.html#jvms-2.5.5"
                              title="2.5.5. Run-Time Constant Pool">2.5.5</a>) of the class of the
            current method.
        </p>
        <p class="note">A frame may be extended with additional
            implementation-specific information, such as debugging
            information.
        </p>
        <p class="norm"><a id="jvms-2.6-120"></a>The sizes of the local
            variable array and the operand stack are determined at compile-time
            and are supplied along with the code for the method associated with
            the frame (<a class="xref" href="./jvms-4.html#jvms-4.7.3"
                          title="4.7.3. The Code Attribute">4.7.3</a>). Thus the size of the frame
            data structure depends only on the implementation of the Java Virtual Machine, and
            the memory for these structures can be allocated simultaneously on
            method invocation.
        </p>
        <p class="norm"><a id="jvms-2.6-200"></a>Only one frame, the frame for
            the executing method, is active at any point in a given thread of
            control. This frame is referred to as the <span class="emphasis"><em>current
                  frame</em></span>, and its method is known as the <span class="emphasis"><em>current
                  method</em></span>. The class in which the current method is defined is
            the <span class="emphasis"><em>current class</em></span>. Operations on local variables
            and the operand stack are typically with reference to the current
            frame.
        </p>
        <p class="norm"><a id="jvms-2.6-210"></a>A frame ceases to be current
            if its method invokes another method or if its method completes. When
            a method is invoked, a new frame is created and becomes current when
            control transfers to the new method. On method return, the current
            frame passes back the result of its method invocation, if any, to the
            previous frame. The current frame is then discarded as the previous
            frame becomes the current one.
        </p>
        <p class="norm"><a id="jvms-2.6-300"></a>Note that a frame created by a
            thread is local to that thread and cannot be referenced by any other
            thread.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.6.1"></a>2.6.1. Local Variables
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.6.1-100"></a>Each frame
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>) contains an array of variables known as
                its <span class="emphasis"><em>local variables</em></span>. The length of the local
                variable array of a frame is determined at compile-time and supplied
                in the binary representation of a class or interface along with the
                code for the method associated with the frame
                (<a class="xref" href="./jvms-4.html#jvms-4.7.3"
                    title="4.7.3. The Code Attribute">4.7.3</a>).
            </p>
            <p class="norm"><a id="jvms-2.6.1-110"></a>A single local variable can
                hold a value of type <code class="literal">boolean</code>, <code class="literal">byte</code>, <code
                        class="literal">char</code>, <code class="literal">short</code>, <code
                        class="literal">int</code>,
                <code class="literal">float</code>, <code class="literal">reference</code>, or <code
                        class="literal">returnAddress</code>. A pair of local variables can hold
                a value of type <code class="literal">long</code> or <code class="literal">double</code>.
            </p>
            <p class="norm"><a id="jvms-2.6.1-200"></a>Local variables are
                addressed by indexing. The index of the first local variable is
                zero. An integer is considered to be an index into the local variable
                array if and only if that integer is between zero and one less than
                the size of the local variable array.
            </p>
            <p class="norm"><a id="jvms-2.6.1-210"></a>A value of type <code class="literal">long</code> or
                type <code class="literal">double</code> occupies two consecutive local variables. Such a value
                may only be addressed using the lesser index. For example, a value of
                type <code class="literal">double</code> stored in the local variable array at index <span
                        class="emphasis"><em>n</em></span>
                actually occupies the local variables with indices <span class="emphasis"><em>n</em></span> and
                <span class="emphasis"><em>n</em></span>+1; however, the local variable at index <span
                        class="emphasis"><em>n</em></span>+1 cannot be
                loaded from. It can be stored into. However, doing so invalidates the
                contents of local variable <span class="emphasis"><em>n</em></span>.
            </p>
            <p class="norm"><a id="jvms-2.6.1-220"></a>The Java Virtual Machine does not require
                <span class="emphasis"><em>n</em></span> to be even. In intuitive terms, values of types <code
                        class="literal">long</code> and
                <code class="literal">double</code> need not be 64-bit aligned in the local variables
                array. Implementors are free to decide the appropriate way to
                represent such values using the two local variables reserved for the
                value.
            </p>
            <p class="norm"><a id="jvms-2.6.1-300"></a>The Java Virtual Machine uses local
                variables to pass parameters on method invocation. On class method
                invocation, any parameters are passed in consecutive local variables
                starting from local variable <span class="emphasis"><em>0</em></span>. On instance
                method invocation, local variable <span class="emphasis"><em>0</em></span> is always
                used to pass a reference to the object on which the instance method is
                being invoked (<code class="literal">this</code> in the Java programming language). Any parameters are
                subsequently passed in consecutive local variables starting from local
                variable <span class="emphasis"><em>1</em></span>.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.6.2"></a>2.6.2. Operand Stacks
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.6.2-100"></a>Each frame
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>) contains a last-in-first-out (LIFO) stack
                known as its <span class="emphasis"><em>operand stack</em></span>. The maximum depth of
                the operand stack of a frame is determined at compile-time and is
                supplied along with the code for the method associated with the frame
                (<a class="xref" href="./jvms-4.html#jvms-4.7.3"
                    title="4.7.3. The Code Attribute">4.7.3</a>).
            </p>
            <p class="norm"><a id="jvms-2.6.2-110"></a>Where it is clear by
                context, we will sometimes refer to the operand stack of the current
                frame as simply the operand stack.
            </p>
            <p class="norm"><a id="jvms-2.6.2-200"></a>The operand stack is empty
                when the frame that contains it is created. The Java Virtual Machine supplies
                instructions to load constants or values from local variables or
                fields onto the operand stack. Other Java Virtual Machine instructions take operands
                from the operand stack, operate on them, and push the result back onto
                the operand stack. The operand stack is also used to prepare
                parameters to be passed to methods and to receive method
                results.
            </p>
            <p class="norm"><a id="jvms-2.6.2-210"></a>For example, the <span class="emphasis"><em>iadd</em></span>
                instruction (<a class="xref"
                                href="./jvms-6.html#jvms-6.5.iadd"
                                title="iadd"><span class="emphasis"><em>iadd</em></span></a>) adds two <code
                        class="literal">int</code> values
                together. It requires that the <code class="literal">int</code> values to be added be the top two
                values of the operand stack, pushed there by previous
                instructions. Both of the <code class="literal">int</code> values are popped from the operand
                stack. They are added, and their sum is pushed back onto the operand
                stack. Subcomputations may be nested on the operand stack, resulting
                in values that can be used by the encompassing computation.
            </p>
            <p class="norm"><a id="jvms-2.6.2-300"></a>Each entry on the operand
                stack can hold a value of any Java Virtual Machine type, including a value of type
                <code class="literal">long</code> or type <code class="literal">double</code>.
            </p>
            <p class="norm"><a id="jvms-2.6.2-310"></a>Values from the operand
                stack must be operated upon in ways appropriate to their types. It is
                not possible, for example, to push two <code class="literal">int</code> values and subsequently
                treat them as a <code class="literal">long</code> or to push two <code class="literal">float</code>
                values and subsequently
                add them with an <span class="emphasis"><em>iadd</em></span> instruction. A small number of Java Virtual
                Machine
                instructions (the <span class="emphasis"><em>dup</em></span> instructions (<a class="xref"
                                                                                              href="./jvms-6.html#jvms-6.5.dup"
                                                                                              title="dup"><span
                        class="emphasis"><em>dup</em></span></a>)
                and <span class="emphasis"><em>swap</em></span> (<a class="xref"
                                                                    href="./jvms-6.html#jvms-6.5.swap"
                                                                    title="swap"><span
                        class="emphasis"><em>swap</em></span></a>)) operate on run-time data
                areas as raw values without regard to their specific types; these
                instructions are defined in such a way that they cannot be used to
                modify or break up individual values. These restrictions on operand
                stack manipulation are enforced through <code class="literal">class</code> file verification
                (<a class="xref" href="./jvms-4.html#jvms-4.10"
                    title="4.10. Verification of class Files">4.10</a>).
            </p>
            <p class="norm"><a id="jvms-2.6.2-400"></a>At any point in time, an
                operand stack has an associated depth, where a value of type <code class="literal">long</code> or
                <code class="literal">double</code> contributes two units to the depth and a value of any other
                type contributes one unit.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.6.3"></a>2.6.3. Dynamic Linking
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.6.3-100"></a>Each frame
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>) contains a reference to the run-time
                constant pool (<a class="xref"
                                  href="./jvms-2.html#jvms-2.5.5"
                                  title="2.5.5. Run-Time Constant Pool">2.5.5</a>) for the type of the
                current method to support <span class="emphasis"><em>dynamic linking</em></span> of the
                method code. The <code class="literal">class</code> file code for a method refers to methods to
                be invoked and variables to be accessed via symbolic
                references. Dynamic linking translates these symbolic method
                references into concrete method references, loading classes as
                necessary to resolve as-yet-undefined symbols, and translates variable
                accesses into appropriate offsets in storage structures associated
                with the run-time location of these variables.
            </p>
            <p class="norm"><a id="jvms-2.6.3-110"></a>This late binding of the
                methods and variables makes changes in other classes that a method
                uses less likely to break this code.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.6.4"></a>2.6.4. Normal Method Invocation Completion
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.6.4-100"></a>A method invocation
                <span class="emphasis"><em>completes normally</em></span> if that invocation does not
                cause an exception (<a class="xref"
                                       href="./jvms-2.html#jvms-2.10"
                                       title="2.10. Exceptions">2.10</a>) to be thrown, either
                directly from the Java Virtual Machine or as a result of executing an explicit
                <code class="literal">throw</code> statement. If the invocation of the current method completes
                normally, then a value may be returned to the invoking method. This
                occurs when the invoked method executes one of the return instructions
                (<a class="xref" href="./jvms-2.html#jvms-2.11.8"
                    title="2.11.8. Method Invocation and Return Instructions">2.11.8</a>), the choice of which must be
                appropriate for the type of the value being returned (if any).
            </p>
            <p class="norm"><a id="jvms-2.6.4-110"></a>The current frame
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>) is used in this case to restore the state
                of the invoker, including its local variables and operand stack, with
                the program counter of the invoker appropriately incremented to skip
                past the method invocation instruction. Execution then continues
                normally in the invoking method's frame with the returned value (if
                any) pushed onto the operand stack of that frame.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.6.5"></a>2.6.5. Abrupt Method Invocation Completion
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.6.5-100"></a>A method invocation
                <span class="emphasis"><em>completes abruptly</em></span> if execution of a Java Virtual Machine
                instruction within the method causes the Java Virtual Machine to throw an exception
                (<a class="xref" href="./jvms-2.html#jvms-2.10"
                    title="2.10. Exceptions">2.10</a>), and that exception is not handled
                within the method. Execution of an <span class="emphasis"><em>athrow</em></span> instruction
                (<a class="xref" href="./jvms-6.html#jvms-6.5.athrow"
                    title="athrow"><span class="emphasis"><em>athrow</em></span></a>) also causes an exception to be
                explicitly thrown and, if the exception is not caught by the current
                method, results in abrupt method invocation completion. A method
                invocation that completes abruptly never returns a value to its
                invoker.
            </p>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.7"></a>2.7. Representation of Objects
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.7-100"></a>The Java Virtual Machine does not mandate any
            particular internal structure for objects.
        </p>
        <p class="note">In some of Oracles implementations of the Java Virtual Machine, a
            reference to a class instance is a pointer to
            a <span class="emphasis"><em>handle</em></span> that is itself a pair of pointers: one
            to a table containing the methods of the object and a pointer to the
            <code class="literal">Class</code> object that represents the type of the object, and the other
            to the memory allocated from the heap for the object data.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.8"></a>2.8. Floating-Point Arithmetic
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.8-100"></a>
            The Java Virtual Machine incorporates a subset of the floating-point arithmetic
            specified in the IEEE 754 Standard (JLS 1.7).
        </p>
        <p class="note">
            In Java SE 15 and later, the Java Virtual Machine uses the 2019 version of the
            IEEE 754 Standard. Prior to Java SE 15, the Java Virtual Machine used the 1985
            version of the IEEE 754 Standard, where the binary32 format was known
            as the single format and the binary64 format was known as the
            double format.
        </p>
        <p class="norm"><a id="jvms-2.8-200"></a>
            Many of the Java Virtual Machine instructions for arithmetic (<a class="xref"
                                                                             href="./jvms-2.html#jvms-2.11.3"
                                                                             title="2.11.3. Arithmetic Instructions">2.11.3</a>)
            and type conversion (<a class="xref"
                                    href="./jvms-2.html#jvms-2.11.4"
                                    title="2.11.4. Type Conversion Instructions">2.11.4</a>) work with floating-point
            numbers. These
            instructions typically correspond to IEEE 754 operations (<a class="xref"
                                                                         href="./jvms-2.html#jvms-2.8-200-A"
                                                                         title="Table 2.8-A. Correspondence with IEEE 754 operations">Table
                2.8-A</a>), except for certain
            instructions described
            below.
        </p>
        <div class="table"><a id="jvms-2.8-200-A"></a>
            <p class="title"><b>Table 2.8-A. Correspondence with IEEE 754 operations</b></p>
            <div class="table-contents">
                <table class="table" summary="Correspondence with IEEE 754 operations" border="1">
                    <colgroup>
                        <col/>
                        <col/>
                    </colgroup>
                    <thead>
                    <tr>
                        <th>Instruction</th>
                        <th>IEEE 754 operation</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><span class="emphasis"><em>dcmp&lt;op&gt;</em></span> (<a class="xref"
                                                                                      href="./jvms-6.html#jvms-6.5.dcmp_op"
                                                                                      title="dcmp&lt;op&gt;"><span
                                class="emphasis"><em>dcmp&lt;op&gt;</em></span></a>),
                            <span class="emphasis"><em>fcmp&lt;op&gt;</em></span> (<a class="xref"
                                                                                      href="./jvms-6.html#jvms-6.5.fcmp_op"
                                                                                      title="fcmp&lt;op&gt;"><span
                                    class="emphasis"><em>fcmp&lt;op&gt;</em></span></a>)
                        </td>
                        <td>compareQuietLess, compareQuietLessEqual,
                            compareQuietGreater, compareQuietGreaterEqual,
                            compareQuietEqual, compareQuietNotEqual
                        </td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>dadd</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.dadd"
                                                                            title="dadd"><span
                                class="emphasis"><em>dadd</em></span></a>),
                            <span class="emphasis"><em>fadd</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.fadd"
                                                                            title="fadd"><span
                                    class="emphasis"><em>fadd</em></span></a>)
                        </td>
                        <td>addition</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>dsub</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.dsub"
                                                                            title="dsub"><span
                                class="emphasis"><em>dsub</em></span></a>),
                            <span class="emphasis"><em>fsub</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.fsub"
                                                                            title="fsub"><span
                                    class="emphasis"><em>fsub</em></span></a>)
                        </td>
                        <td>subtraction</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>dmul</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.dmul"
                                                                            title="dmul"><span
                                class="emphasis"><em>dmul</em></span></a>),
                            <span class="emphasis"><em>fmul</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.fmul"
                                                                            title="fmul"><span
                                    class="emphasis"><em>fmul</em></span></a>)
                        </td>
                        <td>multiplication</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>ddiv</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.ddiv"
                                                                            title="ddiv"><span
                                class="emphasis"><em>ddiv</em></span></a>),
                            <span class="emphasis"><em>fdiv</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.fdiv"
                                                                            title="fdiv"><span
                                    class="emphasis"><em>fdiv</em></span></a>)
                        </td>
                        <td>division</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>dneg</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.dneg"
                                                                            title="dneg"><span
                                class="emphasis"><em>dneg</em></span></a>),
                            <span class="emphasis"><em>fneg</em></span> (<a class="xref"
                                                                            href="./jvms-6.html#jvms-6.5.fneg"
                                                                            title="fneg"><span
                                    class="emphasis"><em>fneg</em></span></a>)
                        </td>
                        <td>negate</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>i2d</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.i2d"
                                                                           title="i2d"><span
                                class="emphasis"><em>i2d</em></span></a>),
                            <span class="emphasis"><em>i2f</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.i2f"
                                                                           title="i2f"><span
                                    class="emphasis"><em>i2f</em></span></a>),
                            <span class="emphasis"><em>l2d</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.l2d"
                                                                           title="l2d"><span
                                    class="emphasis"><em>l2d</em></span></a>),
                            <span class="emphasis"><em>l2f</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.l2f"
                                                                           title="l2f"><span
                                    class="emphasis"><em>l2f</em></span></a>)
                        </td>
                        <td>convertFromInt</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>d2i</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.d2i"
                                                                           title="d2i"><span
                                class="emphasis"><em>d2i</em></span></a>),
                            <span class="emphasis"><em>d2l</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.d2l"
                                                                           title="d2l"><span
                                    class="emphasis"><em>d2l</em></span></a>),
                            <span class="emphasis"><em>f2i</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.f2i"
                                                                           title="f2i"><span
                                    class="emphasis"><em>f2i</em></span></a>),
                            <span class="emphasis"><em>f2l</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.f2l"
                                                                           title="f2l"><span
                                    class="emphasis"><em>f2l</em></span></a>)
                        </td>
                        <td>convertToIntegerTowardZero</td>
                    </tr>
                    <tr>
                        <td><span class="emphasis"><em>d2f</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.d2f"
                                                                           title="d2f"><span
                                class="emphasis"><em>d2f</em></span></a>),
                            <span class="emphasis"><em>f2d</em></span> (<a class="xref"
                                                                           href="./jvms-6.html#jvms-6.5.f2d"
                                                                           title="f2d"><span
                                    class="emphasis"><em>f2d</em></span></a>)
                        </td>
                        <td>convertFormat</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <br class="table-break"/>
        <p class="norm"><a id="jvms-2.8-300"></a>
            The key differences between the floating-point arithmetic supported by
            the Java Virtual Machine and the IEEE 754 Standard are:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-A"></a>
                        The floating-point remainder instructions <span class="emphasis"><em>drem</em></span> (<a
                                class="xref"
                                href="./jvms-6.html#jvms-6.5.drem"
                                title="drem"><span class="emphasis"><em>drem</em></span></a>) and <span
                                class="emphasis"><em>frem</em></span> (<a class="xref"
                                                                          href="./jvms-6.html#jvms-6.5.frem"
                                                                          title="frem"><span
                                class="emphasis"><em>frem</em></span></a>) do not correspond to the IEEE 754
                        remainder operation. The instructions are based on an implied
                        division using the round toward zero rounding policy; the IEEE
                        754 remainder is instead based on an implied division using the
                        round to nearest rounding policy. (Rounding policies are
                        discussed below.)
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-B"></a>
                        The floating-point negate instructions <span class="emphasis"><em>dneg</em></span> (<a
                                class="xref"
                                href="./jvms-6.html#jvms-6.5.dneg"
                                title="dneg"><span class="emphasis"><em>dneg</em></span></a>) and <span
                                class="emphasis"><em>fneg</em></span> (<a class="xref"
                                                                          href="./jvms-6.html#jvms-6.5.fneg"
                                                                          title="fneg"><span
                                class="emphasis"><em>fneg</em></span></a>) do not correspond precisely to the
                        IEEE 754 negate operation. In particular, the instructions do
                        not require the sign bit of a NaN operand to be inverted.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-C"></a>
                        The floating-point instructions of the Java Virtual Machine do not throw
                        exceptions, trap, or otherwise signal the IEEE 754 exceptional
                        conditions of invalid operation, division by zero, overflow,
                        underflow, or inexact.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-D"></a>
                        The Java Virtual Machine does not support IEEE 754 signaling floating-point
                        comparisons, and has no signaling NaN value.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-E"></a>
                        IEEE 754 includes rounding-direction attributes that do not
                        correspond to a rounding policy in the Java Virtual Machine.
                        The Java Virtual Machine
                        does not provide any means to change the rounding policy
                        used by a given floating-point instruction.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.8-300-F"></a>

                        The Java Virtual Machine does not support the binary32 extended and binary64
                        extended floating-point formats defined by IEEE 754.
                        Neither extended range nor extended precision beyond those
                        specified for the <code class="literal">float</code> and <code class="literal">double</code>
                        types
                        may be used when
                        operating on or storing floating-point values.
                    </p>
                </li>
            </ul>
        </div>
        <p class="note">Some IEEE 754 operations without corresponding
            instructions in the Java Virtual Machine are provided via methods in the
            <code class="literal">Math</code> and <code class="literal">StrictMath</code> classes,
            including the <code class="literal">sqrt</code> method for the IEEE 754
            squareRoot operation, the <code class="literal">fma</code> method for the IEEE
            754 fusedMultiplyAdd operation, and the <code class="literal">IEEEremainder</code>
            method for the IEEE 754 remainder operation.
        </p>
        <p class="norm"><a id="jvms-2.8-400"></a>
            The Java Virtual Machine requires support of IEEE 754 <span class="emphasis"><em>subnormal</em></span>
            floating-point numbers and <span class="emphasis"><em>gradual underflow</em></span>,
            which make it easier to prove desirable properties of particular
            numerical algorithms.
        </p>
        <p class="norm-dynamic"><a id="jvms-2.8-500"></a>
            Floating-point arithmetic is an approximation to real arithmetic.
            While there are an infinite number of real numbers, a particular
            floating-point format only has a finite number of values.
            In the Java Virtual Machine, a <span class="emphasis"><em>rounding policy</em></span> is a
            function used to map from a real number to a floating-point value
            in a given format. For real numbers in the representable range of a
            floating-point format, a continuous segment of the real number
            line is mapped to a single floating-point value. The real number
            whose value is numerically equal to a floating-point value is
            mapped to that floating-point value; for example, the real number
            1.5 is mapped to the floating-point value 1.5 in a given format.
            The Java Virtual Machine defines two rounding policies, as follows:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-2.8-500-A"></a>
                        The <span class="emphasis"><em>round to nearest</em></span> rounding policy applies
                        to all floating-point instructions except for (i) conversion to an
                        integer value and (ii) remainder. Under the round to nearest
                        rounding policy, inexact results must be rounded to the
                        representable value nearest to the infinitely precise result;
                        if the two nearest representable values are equally near, then
                        the value whose least significant bit is zero is chosen.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-2.8-500-A.1"></a>
                        The round to nearest rounding policy corresponds to the default
                        rounding-direction attribute for binary arithmetic in IEEE 754,
                        <span class="emphasis"><em>roundTiesToEven</em></span>.
                    </p>
                    <p class="note">The <span class="emphasis"><em>roundTiesToEven</em></span>
                        rounding-direction attribute was known as the "round to nearest"
                        rounding mode in the 1985 version of the IEEE 754 Standard.
                        The rounding policy in the Java Virtual Machine is named after this
                        rounding mode.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm-dynamic"><a id="jvms-2.8-500-B"></a>
                        The <span class="emphasis"><em>round toward zero</em></span> rounding policy applies
                        to (i) conversion of a floating-point value to an integer value by the
                        <span class="emphasis"><em>d2i</em></span>, <span class="emphasis"><em>d2l</em></span>, <span
                                class="emphasis"><em>f2i</em></span>, and <span class="emphasis"><em>f2l</em></span>
                        instructions
                        (<a class="xref"
                            href="./jvms-6.html#jvms-6.5.d2i"
                            title="d2i"><span class="emphasis"><em>d2i</em></span></a>, <a class="xref"
                                                                                           href="./jvms-6.html#jvms-6.5.d2l"
                                                                                           title="d2l"><span
                                class="emphasis"><em>d2l</em></span></a>,
                        <a class="xref" href="./jvms-6.html#jvms-6.5.f2i"
                           title="f2i"><span class="emphasis"><em>f2i</em></span></a>, <a class="xref"
                                                                                          href="./jvms-6.html#jvms-6.5.f2l"
                                                                                          title="f2l"><span
                                class="emphasis"><em>f2l</em></span></a>),
                        and (ii) the floating-point remainder instructions <span class="emphasis"><em>drem</em></span>
                        and
                        <span class="emphasis"><em>frem</em></span>
                        (<a class="xref"
                            href="./jvms-6.html#jvms-6.5.drem"
                            title="drem"><span class="emphasis"><em>drem</em></span></a>, <a class="xref"
                                                                                             href="./jvms-6.html#jvms-6.5.frem"
                                                                                             title="frem"><span
                                class="emphasis"><em>frem</em></span></a>).
                        Under the round toward zero rounding policy, inexact results are
                        rounded to the nearest representable value that is not greater
                        in magnitude than the infinitely precise result. For conversion
                        to integer, the round toward zero rounding policy is equivalent to
                        truncation where fractional significand bits are discarded.
                    </p>
                    <p class="norm-dynamic"><a id="jvms-2.8-500-B.1"></a>
                        The round toward zero rounding policy corresponds to the
                        <span class="emphasis"><em>roundTowardZero</em></span> rounding-direction
                        attribute for binary arithmetic in IEEE 754.
                    </p>
                    <p class="note">The <span class="emphasis"><em>roundTowardZero</em></span>
                        rounding-direction attribute was known as the "round toward zero"
                        rounding mode in the 1985 version of the IEEE 754 Standard.
                        The rounding policy in the Java Virtual Machine is named after this
                        rounding mode.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm-dynamic"><a id="jvms-2.8-510"></a>
            The Java Virtual Machine requires that every floating-point instruction rounds its
            floating-point result to the result precision. The rounding policy used
            by each instruction is either round to nearest or round toward zero,
            as specified above.
        </p>
        <p class="note"><a id="jvms-2.8-600"></a>
            Java 1.0 and 1.1 required <span class="emphasis"><em>strict</em></span> evaluation of
            floating-point expressions. Strict evaluation means that each <code class="literal">float</code>
            operand corresponds to a value representable in the IEEE 754
            binary32 format, each <code class="literal">double</code> operand corresponds to a value
            representable in the IEEE 754 binary64 format, and each
            floating-point operator with a corresponding IEEE 754 operation matches
            the IEEE 754 result for the same operands.
        </p>
        <p class="note">
            Strict evaluation provides predictable results, but caused performance
            problems in the Java Virtual Machine implementations for some processor families
            common in the Java 1.0/1.1 era. Consequently, in Java 1.2 through Java
            SE 16, the Java SE Platform allowed a Java Virtual Machine implementation to have one or
            two <span class="emphasis"><em>value sets</em></span> associated with each
            floating-point type. The <code class="literal">float</code> type was associated with the
            <span class="emphasis"><em>float value set</em></span> and the
            <span class="emphasis"><em>float-extended-exponent value set</em></span>, while the
            <code class="literal">double</code> type was associated with the <span class="emphasis"><em>double value
                  set</em></span> and the <span class="emphasis"><em>double-extended-exponent value
                  set</em></span>. The float value set corresponded to the values
            representable in the IEEE 754 binary32 format; the
            float-extended-exponent value set had the same number of precision
            bits but larger exponent range. Similarly, the double value set
            corresponded to the values representable in the IEEE 754 binary64
            format; the double-extended-exponent value set had the same number of
            precision bits but larger exponent range. Allowing use of the
            extended-exponent value sets by default ameliorated the performance
            problems on some processor families.
        </p>
        <p class="note">
            For compatibility, Java 1.2 allowed a <code class="literal">class</code> file
            to forbid an implementation from using the extended-exponent value
            sets. A <code class="literal">class</code> file expressed this by setting the <code
                class="literal">ACC_STRICT</code> flag
            on the declaration of a method. <code class="literal">ACC_STRICT</code> constrained the
            floating-point semantics of the method's instructions to use the float
            value set for <code class="literal">float</code> operands and the double value set for <code
                class="literal">double</code>
            operands, ensuring the results of such instructions were fully
            predictable. Methods flagged as <code class="literal">ACC_STRICT</code> thus had the same
            floating-point semantics as specified in Java 1.0 and 1.1.
        </p>
        <p class="note">
            In Java SE 17 and later, the Java SE Platform always requires strict
            evaluation of floating-point expressions. Newer members of the
            processor families that had performance problems implementing strict
            evaluation no longer have that difficulty. This specification no
            longer associates <code class="literal">float</code> and <code class="literal">double</code> with the four
            value sets
            described above, and the <code class="literal">ACC_STRICT</code> flag no longer affects the
            evaluation of floating-point operations. For compatibility, the bit
            pattern assigned to denote <code class="literal">ACC_STRICT</code> in a <code class="literal">class</code>
            file whose major
            version number is 46-60 is unassigned (that is, does not denote any
            flag) in a <code class="literal">class</code> file whose major version number is greater than 60
            (<a class="xref" href="./jvms-4.html#jvms-4.6"
                title="4.6. Methods">4.6</a>). Future versions of the Java Virtual Machine may assign
            a different meaning to the bit pattern in future <code class="literal">class</code> files.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.9"></a>2.9. Special Methods
                    </h2>
                </div>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.9.1"></a>2.9.1. Instance Initialization Methods
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.9.1-100"></a>
                A class has zero or more <span class="emphasis"><em>instance initialization
                     methods</em></span>, each typically corresponding to a constructor
                written in the Java programming language.
            </p>
            <p class="norm"><a id="jvms-2.9.1-200"></a>
                A method is an instance initialization method if all of the following
                are true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.1-200-A"></a>
                            It is defined in a class (not an interface).
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.1-200-B"></a>
                            It has the special name <code class="literal">&lt;init&gt;</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.1-200-C"></a>
                            It is <code class="literal">void</code> (<a class="xref"
                                                                        href="./jvms-4.html#jvms-4.3.3"
                                                                        title="4.3.3. Method Descriptors">4.3.3</a>).
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.9.1-210"></a>
                In a class, any non-<code class="literal">void</code> method named <code
                        class="literal">&lt;init&gt;</code> is not an instance
                initialization method. In an interface, any method named <code class="literal">&lt;init&gt;</code> is
                not
                an instance initialization method. Such methods cannot be invoked by
                any Java Virtual Machine instruction (<a class="xref"
                                                         href="./jvms-4.html#jvms-4.4.2"
                                                         title="4.4.2. The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures">4.4.2</a>,
                <a class="xref" href="./jvms-4.html#jvms-4.9.2"
                   title="4.9.2. Structural Constraints">4.9.2</a>) and are rejected by format checking
                (<a class="xref" href="./jvms-4.html#jvms-4.6"
                    title="4.6. Methods">4.6</a>, <a class="xref"
                                                     href="./jvms-4.html#jvms-4.8"
                                                     title="4.8. Format Checking">4.8</a>).
            </p>
            <p class="norm"><a id="jvms-2.9.1-300"></a>
                The declaration and use of an instance initialization method is
                constrained by the Java Virtual Machine. For the declaration, the method's
                <code class="literal">access_flags</code> item and <code class="literal">code</code> array are
                constrained
                (<a class="xref" href="./jvms-4.html#jvms-4.6"
                    title="4.6. Methods">4.6</a>, <a class="xref"
                                                     href="./jvms-4.html#jvms-4.9.2"
                                                     title="4.9.2. Structural Constraints">4.9.2</a>). For a use,
                an instance initialization method may be invoked only by the
                <span class="emphasis"><em>invokespecial</em></span> instruction on an uninitialized class instance
                (<a class="xref" href="./jvms-4.html#jvms-4.10.1.9"
                    title="4.10.1.9. Type Checking Instructions">4.10.1.9</a>).
            </p>
            <p class="note">Because the name <code class="literal">&lt;init&gt;</code> is not a valid identifier in
                the Java programming language, it cannot be used directly in a program written in the
                Java programming language.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.9.2"></a>2.9.2. Class Initialization Methods
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.9.2-100"></a>
                A class or interface has at most one <span class="emphasis"><em>class or interface
                     initialization method</em></span> and is initialized by the Java Virtual Machine
                invoking that method (<a class="xref"
                                         href="./jvms-5.html#jvms-5.5"
                                         title="5.5. Initialization">5.5</a>).
            </p>
            <p class="norm"><a id="jvms-2.9.2-200"></a>
                A method is a <span class="emphasis"><em>class or interface initialization
                     method</em></span> if all of the following are true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.2-200-A"></a>
                            It has the special name <code class="literal">&lt;clinit&gt;</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.2-200-B"></a>
                            It is <code class="literal">void</code> (<a class="xref"
                                                                        href="./jvms-4.html#jvms-4.3.3"
                                                                        title="4.3.3. Method Descriptors">4.3.3</a>).
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.2-200-C"></a>
                            In a <code class="literal">class</code> file whose version number is 51.0 or above, the
                            method has its <code class="literal">ACC_STATIC</code> flag set and takes no arguments
                            (<a class="xref" href="./jvms-4.html#jvms-4.6"
                                title="4.6. Methods">4.6</a>).
                        </p>
                        <p class="note">The requirement for <code class="literal">ACC_STATIC</code> was introduced
                            in Java SE 7, and for taking no arguments in Java SE 9. In a
                            class file whose version number is 50.0 or below, a method named
                            <code class="literal">&lt;clinit&gt;</code> that is <code class="literal">void</code> is
                            considered the class or interface
                            initialization method regardless of the setting of its
                            <code class="literal">ACC_STATIC</code> flag or whether it takes arguments.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.9.2-210"></a>
                Other methods named <code class="literal">&lt;clinit&gt;</code> in a <code class="literal">class</code>
                file are not class or
                interface initialization methods. They are never invoked by the Java Virtual Machine
                itself, cannot be invoked by any Java Virtual Machine instruction
                (<a class="xref" href="./jvms-4.html#jvms-4.9.1"
                    title="4.9.1. Static Constraints">4.9.1</a>), and are rejected by format checking
                (<a class="xref" href="./jvms-4.html#jvms-4.6"
                    title="4.6. Methods">4.6</a>, <a class="xref"
                                                     href="./jvms-4.html#jvms-4.8"
                                                     title="4.8. Format Checking">4.8</a>).
            </p>
            <p class="note">Because the name <code class="literal">&lt;clinit&gt;</code> is not a valid identifier
                in the Java programming language, it cannot be used directly in a program written in
                the Java programming language.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.9.3"></a>2.9.3. Signature Polymorphic Methods
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.9.3-100"></a>
                A method is <span class="emphasis"><em>signature polymorphic</em></span> if all of the
                following are true:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.3-100-A"></a>
                            It is declared in the <code class="literal">java.lang.invoke.MethodHandle</code> class or
                            the
                            <code class="literal">java.lang.invoke.VarHandle</code> class.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.3-100-B"></a>
                            It has a single formal parameter of type <code class="literal">Object</code><code
                                    class="literal">[]</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.9.3-100-C"></a>
                            It has the <code class="literal">ACC_VARARGS</code> and <code
                                    class="literal">ACC_NATIVE</code>
                            flags set.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.9.3-200"></a>
                The Java Virtual Machine gives special treatment to signature polymorphic methods in
                the <span class="emphasis"><em>invokevirtual</em></span> instruction (<a class="xref"
                                                                                         href="./jvms-6.html#jvms-6.5.invokevirtual"
                                                                                         title="invokevirtual"><span
                        class="emphasis"><em>invokevirtual</em></span></a>),
                in order to effect invocation of a <span class="emphasis"><em>method handle</em></span>
                or to effect access to a variable referenced by an instance of <code
                        class="literal">java.lang.invoke.VarHandle</code>.
            </p>
            <p class="norm"><a id="jvms-2.9.3-210"></a>
                A method handle is a dynamically strongly typed and directly
                executable reference to an underlying method, constructor, field, or
                similar low-level operation (<a class="xref"
                                                href="./jvms-5.html#jvms-5.4.3.5"
                                                title="5.4.3.5. Method Type and Method Handle Resolution">5.4.3.5</a>),
                with
                optional transformations of arguments or return values. An instance of
                <code class="literal">java.lang.invoke.VarHandle</code> is a dynamically strongly typed reference to a
                variable or
                family of variables, including <code class="literal">static</code> fields, non-<code
                        class="literal">static</code> fields,
                array elements, or components of an off-heap data structure. See
                the <code class="literal">java.lang.invoke</code> package in the Java SE Platform API
                for more information.
            </p>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.10"></a>2.10. Exceptions
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.10-100"></a>An exception in the Java Virtual Machine is
            represented by an instance of the class <code class="literal">Throwable</code> or one of its
            subclasses. Throwing an exception results in an immediate nonlocal
            transfer of control from the point where the exception was
            thrown.
        </p>
        <p class="norm"><a id="jvms-2.10-110"></a>Most exceptions occur
            synchronously as a result of an action by the thread in which they
            occur. An asynchronous exception, by contrast, can potentially occur
            at any point in the execution of a program. The Java Virtual Machine throws an
            exception for one of three reasons:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.10-110-A"></a>An <span class="emphasis"><em>athrow</em></span>
                        instruction
                        (<a class="xref"
                            href="./jvms-6.html#jvms-6.5.athrow"
                            title="athrow"><span class="emphasis"><em>athrow</em></span></a>) was executed.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.10-110-B"></a>An abnormal execution
                        condition was synchronously detected by the Java Virtual Machine. These
                        exceptions are not thrown at an arbitrary point in the program,
                        but only synchronously after execution of an instruction that
                        either:
                    </p>
                    <div class="norm">
                        <ul class="norm" style="list-style-type: circle; ">
                            <li class="listitem">
                                <p class="norm"><a id="jvms-2.10-110-B-A"></a>Specifies the
                                    exception as a possible result, such as:
                                </p>
                                <div class="norm">
                                    <ul class="norm" style="list-style-type: square; ">
                                        <li class="listitem">
                                            <p class="norm"><a id="jvms-2.10-110-B-A-A"></a>When the
                                                instruction embodies an operation that violates the
                                                semantics of the Java programming language, for example indexing outside
                                                the bounds of an array.
                                            </p>
                                        </li>
                                        <li class="listitem">
                                            <p class="norm"><a id="jvms-2.10-110-B-A-B"></a>When an
                                                error occurs in loading or linking part of the
                                                program.
                                            </p>
                                        </li>
                                    </ul>
                                </div>
                            </li>
                            <li class="listitem">
                                <p class="norm"><a id="jvms-2.10-110-B-B"></a>Causes some limit
                                    on a resource to be exceeded, for example when too much memory
                                    is used.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.10-110-C"></a>
                        An asynchronous exception occurred because an internal error
                        occurred in the Java Virtual Machine implementation (<a class="xref"
                                                                                href="./jvms-6.html#jvms-6.3"
                                                                                title="6.3. Virtual Machine Errors">6.3</a>).
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.10-200"></a>A Java Virtual Machine implementation may
            permit a small but bounded amount of execution to occur before an
            asynchronous exception is thrown. This delay is permitted to allow
            optimized code to detect and throw these exceptions at points where it
            is practical to handle them while obeying the semantics of the
            Java programming language.
        </p>
        <p class="note">A simple implementation might poll for asynchronous
            exceptions at the point of each control transfer instruction. Since a
            program has a finite size, this provides a bound on the total delay in
            detecting an asynchronous exception. Since no asynchronous exception
            will occur between control transfers, the code generator has some
            flexibility to reorder computation between control transfers for
            greater performance. The paper <em class="citetitle">Polling Efficiently on Stock
                Hardware</em> by Marc Feeley, <em class="citetitle">Proc. 1993 Conference
                on Functional Programming and Computer Architecture</em>,
            Copenhagen, Denmark, pp. 179187, is recommended as further
            reading.
        </p>
        <p class="norm"><a id="jvms-2.10-300"></a>Exceptions thrown by the
            Java Virtual Machine are precise: when the transfer of control takes place, all
            effects of the instructions executed before the point from which the
            exception is thrown must appear to have taken place. No instructions
            that occur after the point from which the exception is thrown may
            appear to have been evaluated. If optimized code has speculatively
            executed some of the instructions which follow the point at which the
            exception occurs, such code must be prepared to hide this speculative
            execution from the user-visible state of the program.
        </p>
        <p class="norm"><a id="jvms-2.10-400"></a>Each method in the Java Virtual Machine may
            be associated with zero or more <span class="emphasis"><em>exception
                  handlers</em></span>. An exception handler specifies the range of
            offsets into the Java Virtual Machine code implementing the method for which the
            exception handler is active, describes the type of exception that the
            exception handler is able to handle, and specifies the location of the
            code that is to handle that exception. An exception matches an
            exception handler if the offset of the instruction that caused the
            exception is in the range of offsets of the exception handler and the
            exception type is the same class as or a subclass of the class of
            exception that the exception handler handles. When an exception is
            thrown, the Java Virtual Machine searches for a matching exception handler in the
            current method. If a matching exception handler is found, the system
            branches to the exception handling code specified by the matched
            handler.
        </p>
        <p class="norm"><a id="jvms-2.10-410"></a>
            If no such exception handler is found in the current method, the
            current method invocation completes abruptly (<a class="xref"
                                                             href="./jvms-2.html#jvms-2.6.5"
                                                             title="2.6.5. Abrupt Method Invocation Completion">2.6.5</a>).
            On abrupt completion, the operand stack
            and
            local variables of the current method invocation are discarded, and
            its frame is popped, reinstating the frame of the invoking method. The
            exception is then rethrown in the context of the invoker's frame and
            so on, continuing up the method invocation chain. If no suitable
            exception handler is found before the top of the method invocation
            chain is reached, the execution of the thread in which the exception
            was thrown is terminated. Before termination of the
            thread, the uncaught exception is handled according to the following
            rules:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.10-410-A"></a>
                        If the thread has an uncaught exception handler set, then that
                        handler is executed.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.10-410-B"></a>
                        Otherwise, the method <code class="literal">uncaughtException</code> is invoked for the
                        <code class="literal">ThreadGroup</code> that is the parent of the thread. If the
                        <code class="literal">ThreadGroup</code> and its parent <code class="literal">ThreadGroup</code>s
                        do not
                        override <code class="literal">uncaughtException</code>, then the default handler's
                        <code class="literal">uncaughtException</code> method is invoked.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.10-420"></a>The order in which the
            exception handlers of a method are searched for a match is
            important. Within a <code class="literal">class</code> file, the exception handlers for each
            method are stored in a table (<a class="xref"
                                             href="./jvms-4.html#jvms-4.7.3"
                                             title="4.7.3. The Code Attribute">4.7.3</a>). At run
            time, when an exception is thrown, the Java Virtual Machine searches the exception
            handlers of the current method in the order that they appear in the
            corresponding exception handler table in the <code class="literal">class</code> file, starting
            from the beginning of that table.
        </p>
        <p class="norm"><a id="jvms-2.10-430"></a>Note that the Java Virtual Machine does not
            enforce nesting of or any ordering of the exception table entries of a
            method. The exception handling semantics of the Java programming language are
            implemented only through cooperation with the compiler
            (<a class="xref" href="./jvms-3.html#jvms-3.12"
                title="3.12. Throwing and Handling Exceptions">3.12</a>). When <code class="literal">class</code> files
            are generated by
            some other means, the defined search procedure ensures that
            all Java Virtual Machine implementations will behave
            consistently.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.11"></a>2.11. Instruction Set Summary
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.11-100"></a>A Java Virtual Machine instruction consists
            of a one-byte <span class="emphasis"><em>opcode</em></span> specifying the operation to
            be performed, followed by zero or more <span class="emphasis"><em>operands</em></span>
            supplying arguments or data that are used by the operation. Many
            instructions have no operands and consist only of an opcode.
        </p>
        <p class="norm"><a id="jvms-2.11-110"></a>Ignoring exceptions, the
            inner loop of a Java Virtual Machine interpreter is effectively
        </p>
        <pre class="screen">do {
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
</pre>
        <p class="norm"><a id="jvms-2.11-200"></a>The number and size of the
            operands are determined by the opcode. If an operand is more than one
            byte in size, then it is stored in <span class="emphasis"><em>big-endian</em></span>
            order - high-order byte first. For example, an unsigned 16-bit index
            into the local variables is stored as two unsigned
            bytes, <span class="emphasis"><em>byte1</em></span> and
            <span class="emphasis"><em>byte2</em></span>, such that its value is
            (<span class="emphasis"><em>byte1</em></span> <code class="literal">&lt;&lt;</code> 8)
            | <span class="emphasis"><em>byte2</em></span>.
        </p>
        <p class="norm"><a id="jvms-2.11-210"></a>The bytecode instruction
            stream is only single-byte aligned. The two exceptions are the
            <span class="emphasis"><em>lookupswitch</em></span> and <span class="emphasis"><em>tableswitch</em></span>
            instructions
            (<a class="xref"
                href="./jvms-6.html#jvms-6.5.lookupswitch"
                title="lookupswitch"><span class="emphasis"><em>lookupswitch</em></span></a>,
            <a class="xref" href="./jvms-6.html#jvms-6.5.tableswitch"
               title="tableswitch"><span class="emphasis"><em>tableswitch</em></span></a>), which are padded to force
            internal alignment of some of their operands on 4-byte
            boundaries.
        </p>
        <p class="note">The decision to limit the Java Virtual Machine opcode to a byte and
            to forgo data alignment within compiled code reflects a conscious bias
            in favor of compactness, possibly at the cost of some performance in
            naive implementations. A one-byte opcode also limits the size of the
            instruction set. Not assuming data alignment means that immediate data
            larger than a byte must be constructed from bytes at run time on many
            machines.
        </p>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.1"></a>2.11.1. Types and the Java Virtual Machine
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.1-100"></a>Most of the instructions in
                the Java Virtual Machine instruction set encode type information about the operations
                they perform. For instance, the <span class="emphasis"><em>iload</em></span> instruction
                (<a class="xref" href="./jvms-6.html#jvms-6.5.iload"
                    title="iload"><span class="emphasis"><em>iload</em></span></a>) loads the contents of a local
                variable, which must be an <code class="literal">int</code>, onto the operand stack. The <span
                        class="emphasis"><em>fload</em></span>
                instruction (<a class="xref"
                                href="./jvms-6.html#jvms-6.5.fload"
                                title="fload"><span class="emphasis"><em>fload</em></span></a>) does the same with a
                <code class="literal">float</code> value. The two instructions may have identical
                implementations, but have distinct opcodes.
            </p>
            <p class="norm"><a id="jvms-2.11.1-110"></a>For the majority of typed
                instructions, the instruction type is represented explicitly in the
                opcode mnemonic by a letter: <span class="emphasis"><em>i</em></span> for an <code
                        class="literal">int</code> operation, <span class="emphasis"><em>l</em></span> for
                <code class="literal">long</code>, <span class="emphasis"><em>s</em></span> for <code
                        class="literal">short</code>, <span class="emphasis"><em>b</em></span> for <code
                        class="literal">byte</code>, <span class="emphasis"><em>c</em></span> for <code
                        class="literal">char</code>,
                <span class="emphasis"><em>f</em></span> for <code class="literal">float</code>, <span
                        class="emphasis"><em>d</em></span> for <code class="literal">double</code>, and <span
                        class="emphasis"><em>a</em></span> for <code class="literal">reference</code>. Some
                instructions for which the type is unambiguous do not have a type
                letter in their mnemonic. For instance, <span class="emphasis"><em>arraylength</em></span> always
                operates
                on an object that is an array. Some instructions, such as <span class="emphasis"><em>goto</em></span>,
                an
                unconditional control transfer, do not operate on typed
                operands.
            </p>
            <p class="norm"><a id="jvms-2.11.1-120"></a>Given the Java Virtual Machine's one-byte
                opcode size, encoding types into opcodes places pressure on the design
                of its instruction set. If each typed instruction supported all of the
                Java Virtual Machine's run-time data types, there would be more instructions than
                could be represented in a byte. Instead, the instruction set of the
                Java Virtual Machine provides a reduced level of type support for certain
                operations. In other words, the instruction set is intentionally not
                orthogonal. Separate instructions can be used to convert between
                unsupported and supported data types as necessary.
            </p>
            <p class="norm"><a id="jvms-2.11.1-200"></a>
                <a class="xref" href="./jvms-2.html#jvms-2.11.1-220"
                   title="Table 2.11.1-A. Type support in the Java Virtual Machine instruction set">Table 2.11.1-A</a>
                summarizes the type support in the
                instruction set of the Java Virtual Machine. A specific instruction, with type
                information, is built by replacing the <span class="emphasis"><em>T</em></span> in the
                instruction template in the opcode column by the letter in the type
                column. If the type column for some instruction template and type is
                blank, then no instruction exists supporting that type of
                operation. For instance, there is a load instruction for type <code class="literal">int</code>,
                <span class="emphasis"><em>iload</em></span>, but there is no load instruction for type <code
                        class="literal">byte</code>.
            </p>
            <p class="norm"><a id="jvms-2.11.1-210"></a>Note that most instructions
                in <a class="xref" href="./jvms-2.html#jvms-2.11.1-220"
                      title="Table 2.11.1-A. Type support in the Java Virtual Machine instruction set">Table
                    2.11.1-A</a>
                do not have forms for the
                integral types <code class="literal">byte</code>, <code class="literal">char</code>, and <code
                        class="literal">short</code>. None have forms for the
                <code class="literal">boolean</code> type. A compiler encodes loads of literal values of types
                <code class="literal">byte</code> and <code class="literal">short</code> using Java Virtual Machine
                instructions that sign-extend those
                values to values of type <code class="literal">int</code> at compile-time or run-time. Loads of
                literal values of types <code class="literal">boolean</code> and <code class="literal">char</code> are
                encoded using
                instructions that zero-extend the literal to a value of type <code class="literal">int</code> at
                compile-time or run-time. Likewise, loads from arrays of values of
                type <code class="literal">boolean</code>, <code class="literal">byte</code>, <code
                        class="literal">short</code>, and <code class="literal">char</code> are encoded using Java
                Virtual
                Machine
                instructions that sign-extend or zero-extend the values to values of
                type <code class="literal">int</code>. Thus, most operations on values of actual types <code
                        class="literal">boolean</code>,
                <code class="literal">byte</code>, <code class="literal">char</code>, and <code
                        class="literal">short</code> are correctly performed by instructions
                operating on values of computational type <code class="literal">int</code>.
            </p>
            <div class="table"><a id="jvms-2.11.1-220"></a>
                <p class="title"><b>Table 2.11.1-A. Type support in the Java Virtual Machine instruction
                    set</b></p>
                <div class="table-contents">
                    <table class="table" summary="Type support in the Java Virtual Machine instruction set" border="1">
                        <colgroup>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                            <col/>
                        </colgroup>
                        <thead>
                        <tr>
                            <th>opcode</th>
                            <th><code class="literal">byte</code></th>
                            <th><code class="literal">short</code></th>
                            <th><code class="literal">int</code></th>
                            <th><code class="literal">long</code></th>
                            <th><code class="literal">float</code></th>
                            <th><code class="literal">double</code></th>
                            <th><code class="literal">char</code></th>
                            <th><code class="literal">reference</code></th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td><span class="emphasis"><em>Tipush</em></span></td>
                            <td><span class="emphasis"><em>bipush</em></span></td>
                            <td><span class="emphasis"><em>sipush</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tconst</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iconst</em></span></td>
                            <td><span class="emphasis"><em>lconst</em></span></td>
                            <td><span class="emphasis"><em>fconst</em></span></td>
                            <td><span class="emphasis"><em>dconst</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>aconst</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tload</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iload</em></span></td>
                            <td><span class="emphasis"><em>lload</em></span></td>
                            <td><span class="emphasis"><em>fload</em></span></td>
                            <td><span class="emphasis"><em>dload</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>aload</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tstore</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>istore</em></span></td>
                            <td><span class="emphasis"><em>lstore</em></span></td>
                            <td><span class="emphasis"><em>fstore</em></span></td>
                            <td><span class="emphasis"><em>dstore</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>astore</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tinc</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iinc</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Taload</em></span></td>
                            <td><span class="emphasis"><em>baload</em></span></td>
                            <td><span class="emphasis"><em>saload</em></span></td>
                            <td><span class="emphasis"><em>iaload</em></span></td>
                            <td><span class="emphasis"><em>laload</em></span></td>
                            <td><span class="emphasis"><em>faload</em></span></td>
                            <td><span class="emphasis"><em>daload</em></span></td>
                            <td><span class="emphasis"><em>caload</em></span></td>
                            <td><span class="emphasis"><em>aaload</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tastore</em></span></td>
                            <td><span class="emphasis"><em>bastore</em></span></td>
                            <td><span class="emphasis"><em>sastore</em></span></td>
                            <td><span class="emphasis"><em>iastore</em></span></td>
                            <td><span class="emphasis"><em>lastore</em></span></td>
                            <td><span class="emphasis"><em>fastore</em></span></td>
                            <td><span class="emphasis"><em>dastore</em></span></td>
                            <td><span class="emphasis"><em>castore</em></span></td>
                            <td><span class="emphasis"><em>aastore</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tadd</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iadd</em></span></td>
                            <td><span class="emphasis"><em>ladd</em></span></td>
                            <td><span class="emphasis"><em>fadd</em></span></td>
                            <td><span class="emphasis"><em>dadd</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tsub</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>isub</em></span></td>
                            <td><span class="emphasis"><em>lsub</em></span></td>
                            <td><span class="emphasis"><em>fsub</em></span></td>
                            <td><span class="emphasis"><em>dsub</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tmul</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>imul</em></span></td>
                            <td><span class="emphasis"><em>lmul</em></span></td>
                            <td><span class="emphasis"><em>fmul</em></span></td>
                            <td><span class="emphasis"><em>dmul</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tdiv</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>idiv</em></span></td>
                            <td><span class="emphasis"><em>ldiv</em></span></td>
                            <td><span class="emphasis"><em>fdiv</em></span></td>
                            <td><span class="emphasis"><em>ddiv</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Trem</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>irem</em></span></td>
                            <td><span class="emphasis"><em>lrem</em></span></td>
                            <td><span class="emphasis"><em>frem</em></span></td>
                            <td><span class="emphasis"><em>drem</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tneg</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ineg</em></span></td>
                            <td><span class="emphasis"><em>lneg</em></span></td>
                            <td><span class="emphasis"><em>fneg</em></span></td>
                            <td><span class="emphasis"><em>dneg</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tshl</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ishl</em></span></td>
                            <td><span class="emphasis"><em>lshl</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tshr</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ishr</em></span></td>
                            <td><span class="emphasis"><em>lshr</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tushr</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iushr</em></span></td>
                            <td><span class="emphasis"><em>lushr</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tand</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>iand</em></span></td>
                            <td><span class="emphasis"><em>land</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tor</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ior</em></span></td>
                            <td><span class="emphasis"><em>lor</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Txor</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ixor</em></span></td>
                            <td><span class="emphasis"><em>lxor</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>i2T</em></span></td>
                            <td><span class="emphasis"><em>i2b</em></span></td>
                            <td><span class="emphasis"><em>i2s</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>i2l</em></span></td>
                            <td><span class="emphasis"><em>i2f</em></span></td>
                            <td><span class="emphasis"><em>i2d</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>l2T</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>l2i</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>l2f</em></span></td>
                            <td><span class="emphasis"><em>l2d</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>f2T</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>f2i</em></span></td>
                            <td><span class="emphasis"><em>f2l</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>f2d</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>d2T</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>d2i</em></span></td>
                            <td><span class="emphasis"><em>d2l</em></span></td>
                            <td><span class="emphasis"><em>d2f</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tcmp</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>lcmp</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tcmpl</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>fcmpl</em></span></td>
                            <td><span class="emphasis"><em>dcmpl</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Tcmpg</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>fcmpg</em></span></td>
                            <td><span class="emphasis"><em>dcmpg</em></span></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>if_TcmpOP</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>if_icmpOP</em></span></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>if_acmpOP</em></span></td>
                        </tr>
                        <tr>
                            <td><span class="emphasis"><em>Treturn</em></span></td>
                            <td></td>
                            <td></td>
                            <td><span class="emphasis"><em>ireturn</em></span></td>
                            <td><span class="emphasis"><em>lreturn</em></span></td>
                            <td><span class="emphasis"><em>freturn</em></span></td>
                            <td><span class="emphasis"><em>dreturn</em></span></td>
                            <td></td>
                            <td><span class="emphasis"><em>areturn</em></span></td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <br class="table-break"/>
            <p class="norm"><a id="jvms-2.11.1-300"></a>The mapping between Java Virtual Machine
                actual types and Java Virtual Machine computational types is summarized by
                <a class="xref" href="./jvms-2.html#jvms-2.11.1-320"
                   title="Table 2.11.1-B. Actual and Computational types in the Java Virtual Machine">Table 2.11.1-B</a>.
            </p>
            <p class="norm"><a id="jvms-2.11.1-310"></a>Certain Java Virtual Machine instructions
                such as <span class="emphasis"><em>pop</em></span> and <span class="emphasis"><em>swap</em></span>
                operate on the operand stack without regard
                to type; however, such instructions are constrained to use only on
                values of certain categories of computational types, also given in
                <a class="xref" href="./jvms-2.html#jvms-2.11.1-320"
                   title="Table 2.11.1-B. Actual and Computational types in the Java Virtual Machine">Table 2.11.1-B</a>.
            </p>
            <div class="table"><a id="jvms-2.11.1-320"></a>
                <p class="title"><b>Table 2.11.1-B. Actual and Computational types in the Java Virtual
                    Machine</b></p>
                <div class="table-contents">
                    <table class="table" summary="Actual and Computational types in the Java Virtual Machine"
                           border="1">
                        <colgroup>
                            <col/>
                            <col/>
                            <col/>
                        </colgroup>
                        <thead>
                        <tr>
                            <th>Actual type</th>
                            <th>Computational type</th>
                            <th>Category</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td><code class="literal">boolean</code></td>
                            <td><code class="literal">int</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">byte</code></td>
                            <td><code class="literal">int</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">char</code></td>
                            <td><code class="literal">int</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">short</code></td>
                            <td><code class="literal">int</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">int</code></td>
                            <td><code class="literal">int</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">float</code></td>
                            <td><code class="literal">float</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">reference</code></td>
                            <td><code class="literal">reference</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">returnAddress</code></td>
                            <td><code class="literal">returnAddress</code></td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td><code class="literal">long</code></td>
                            <td><code class="literal">long</code></td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td><code class="literal">double</code></td>
                            <td><code class="literal">double</code></td>
                            <td>2</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <br class="table-break"/>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.2"></a>2.11.2. Load and Store Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.2-100"></a>The load and store
                instructions transfer values between the local variables
                (<a class="xref" href="./jvms-2.html#jvms-2.6.1"
                    title="2.6.1. Local Variables">2.6.1</a>) and the operand stack
                (<a class="xref" href="./jvms-2.html#jvms-2.6.2"
                    title="2.6.2. Operand Stacks">2.6.2</a>) of a Java Virtual Machine frame
                (<a class="xref" href="./jvms-2.html#jvms-2.6"
                    title="2.6. Frames">2.6</a>):
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.2-100-A"></a>Load a local variable
                            onto the operand stack: <span class="emphasis"><em>iload</em></span>, <span
                                    class="emphasis"><em>iload_&lt;n&gt;</em></span>, <span
                                    class="emphasis"><em>lload</em></span>, <span
                                    class="emphasis"><em>lload_&lt;n&gt;</em></span>,
                            <span class="emphasis"><em>fload</em></span>, <span
                                    class="emphasis"><em>fload_&lt;n&gt;</em></span>, <span
                                    class="emphasis"><em>dload</em></span>, <span
                                    class="emphasis"><em>dload_&lt;n&gt;</em></span>, <span
                                    class="emphasis"><em>aload</em></span>, <span
                                    class="emphasis"><em>aload_&lt;n&gt;</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.2-100-B"></a>Store a value from
                            the operand stack into a local variable: <span class="emphasis"><em>istore</em></span>,
                            <span
                                    class="emphasis"><em>istore_&lt;n&gt;</em></span>,
                            <span class="emphasis"><em>lstore</em></span>, <span
                                    class="emphasis"><em>lstore_&lt;n&gt;</em></span>, <span
                                    class="emphasis"><em>fstore</em></span>, <span
                                    class="emphasis"><em>fstore_&lt;n&gt;</em></span>, <span
                                    class="emphasis"><em>dstore</em></span>, <span
                                    class="emphasis"><em>dstore_&lt;n&gt;</em></span>,
                            <span class="emphasis"><em>astore</em></span>, <span
                                    class="emphasis"><em>astore_&lt;n&gt;</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.2-100-C"></a>Load a constant on to
                            the operand stack: <span class="emphasis"><em>bipush</em></span>, <span
                                    class="emphasis"><em>sipush</em></span>, <span class="emphasis"><em>ldc</em></span>,
                            <span
                                    class="emphasis"><em>ldc_w</em></span>, <span
                                    class="emphasis"><em>ldc2_w</em></span>,
                            <span class="emphasis"><em>aconst_null</em></span>, <span
                                    class="emphasis"><em>iconst_m1</em></span>, <span
                                    class="emphasis"><em>iconst_&lt;i&gt;</em></span>, <span
                                    class="emphasis"><em>lconst_&lt;l&gt;</em></span>, <span
                                    class="emphasis"><em>fconst_&lt;f&gt;</em></span>,
                            <span class="emphasis"><em>dconst_&lt;d&gt;</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.2-100-D"></a>Gain access to more
                            local variables using a wider index, or to a larger immediate
                            operand: <span class="emphasis"><em>wide</em></span>.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.2-110"></a>Instructions that access
                fields of objects and elements of arrays
                (<a class="xref" href="./jvms-2.html#jvms-2.11.5"
                    title="2.11.5. Object Creation and Manipulation">2.11.5</a>) also transfer data to and from the
                operand stack.
            </p>
            <p class="norm"><a id="jvms-2.11.2-200"></a>Instruction mnemonics shown
                above with trailing letters between angle brackets (for instance,
                <span class="emphasis"><em>iload_&lt;n&gt;</em></span>) denote families of instructions (with
                members <span class="emphasis"><em>iload_0</em></span>, <span class="emphasis"><em>iload_1</em></span>,
                <span class="emphasis"><em>iload_2</em></span>,
                and <span class="emphasis"><em>iload_3</em></span> in the case of <span
                        class="emphasis"><em>iload_&lt;n&gt;</em></span>). Such
                families of instructions are specializations of an additional generic
                instruction (<span class="emphasis"><em>iload</em></span>) that takes one operand. For the specialized
                instructions, the operand is implicit and does not need to be stored
                or fetched. The semantics are otherwise the same
                (<span class="emphasis"><em>iload_0</em></span> means the same thing as <span
                        class="emphasis"><em>iload</em></span> with the
                operand <span class="emphasis"><em>0</em></span>). The letter between the angle brackets
                specifies the type of the implicit operand for that family of
                instructions: for <span class="emphasis"><em>&lt;n&gt;</em></span>, a nonnegative
                integer; for <span class="emphasis"><em>&lt;i&gt;</em></span>, an <code class="literal">int</code>;
                for <span class="emphasis"><em>&lt;l&gt;</em></span>, a <code class="literal">long</code>;
                for <span class="emphasis"><em>&lt;f&gt;</em></span>, a <code class="literal">float</code>; and
                for <span class="emphasis"><em>&lt;d&gt;</em></span>, a <code class="literal">double</code>. Forms for
                type <code class="literal">int</code>
                are used in many cases to perform operations on values of type <code class="literal">byte</code>,
                <code class="literal">char</code>, and <code class="literal">short</code> (<a class="xref"
                                                                                              href="./jvms-2.html#jvms-2.11.1"
                                                                                              title="2.11.1. Types and the Java Virtual Machine">2.11.1</a>).
            </p>
            <p class="norm"><a id="jvms-2.11.2-300"></a>This notation for
                instruction families is used throughout this specification.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.3"></a>2.11.3. Arithmetic Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.3-100"></a>
                The arithmetic instructions compute a result that is typically a
                function of two values on the operand stack, pushing the result back
                on the operand stack. There are two main kinds of arithmetic
                instructions: those operating on integer values and those
                operating on floating-point values. Within each of
                these kinds, the arithmetic instructions are specialized to Java Virtual Machine
                numeric types. There is no direct support for integer arithmetic on
                values of the <code class="literal">byte</code>, <code class="literal">short</code>, and <code
                        class="literal">char</code> types
                (<a class="xref" href="./jvms-2.html#jvms-2.11.1"
                    title="2.11.1. Types and the Java Virtual Machine">2.11.1</a>), or for values of the <code
                        class="literal">boolean</code> type;
                those operations are handled by instructions operating on type
                <code class="literal">int</code>. Integer and floating-point instructions also differ in their
                behavior on overflow and divide-by-zero. The arithmetic instructions
                are as follows:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-A"></a>
                            Add: <span class="emphasis"><em>iadd</em></span>, <span
                                    class="emphasis"><em>ladd</em></span>,
                            <span class="emphasis"><em>fadd</em></span>, <span class="emphasis"><em>dadd</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-B"></a>
                            Subtract: <span class="emphasis"><em>isub</em></span>, <span
                                    class="emphasis"><em>lsub</em></span>, <span class="emphasis"><em>fsub</em></span>,
                            <span
                                    class="emphasis"><em>dsub</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-C"></a>
                            Multiply: <span class="emphasis"><em>imul</em></span>, <span
                                    class="emphasis"><em>lmul</em></span>, <span class="emphasis"><em>fmul</em></span>,
                            <span
                                    class="emphasis"><em>dmul</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-D"></a>
                            Divide: <span class="emphasis"><em>idiv</em></span>, <span
                                    class="emphasis"><em>ldiv</em></span>, <span class="emphasis"><em>fdiv</em></span>,
                            <span
                                    class="emphasis"><em>ddiv</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-E"></a>
                            Remainder: <span class="emphasis"><em>irem</em></span>, <span
                                    class="emphasis"><em>lrem</em></span>, <span class="emphasis"><em>frem</em></span>,
                            <span
                                    class="emphasis"><em>drem</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-F"></a>
                            Negate: <span class="emphasis"><em>ineg</em></span>, <span
                                    class="emphasis"><em>lneg</em></span>, <span class="emphasis"><em>fneg</em></span>,
                            <span
                                    class="emphasis"><em>dneg</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-G"></a>
                            Shift: <span class="emphasis"><em>ishl</em></span>, <span
                                    class="emphasis"><em>ishr</em></span>,
                            <span class="emphasis"><em>iushr</em></span>, <span class="emphasis"><em>lshl</em></span>,
                            <span
                                    class="emphasis"><em>lshr</em></span>, <span class="emphasis"><em>lushr</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-H"></a>
                            Bitwise OR: <span class="emphasis"><em>ior</em></span>, <span
                                    class="emphasis"><em>lor</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-I"></a>
                            Bitwise AND: <span class="emphasis"><em>iand</em></span>, <span
                                    class="emphasis"><em>land</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-J"></a>Bitwise exclusive OR:
                            <span class="emphasis"><em>ixor</em></span>, <span class="emphasis"><em>lxor</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-K"></a>
                            Local variable increment: <span class="emphasis"><em>iinc</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.3-100-L"></a>
                            Comparison: <span class="emphasis"><em>dcmpg</em></span>, <span
                                    class="emphasis"><em>dcmpl</em></span>, <span class="emphasis"><em>fcmpg</em></span>,
                            <span
                                    class="emphasis"><em>fcmpl</em></span>, <span class="emphasis"><em>lcmp</em></span>.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.3-110"></a>
                The semantics of the Java programming language operators on integer and floating-point
                values (JLS 4.2.2, JLS 4.2.4) are directly supported by the
                semantics of the Java Virtual Machine instruction set.
            </p>
            <p class="norm"><a id="jvms-2.11.3-200"></a>
                The Java Virtual Machine does not indicate overflow during operations on integer
                data types. The only integer operations that can throw an exception
                are the integer divide instructions (<span class="emphasis"><em>idiv</em></span> and <span
                        class="emphasis"><em>ldiv</em></span>) and the
                integer remainder instructions (<span class="emphasis"><em>irem</em></span> and <span
                        class="emphasis"><em>lrem</em></span>), which throw
                an <code class="literal">ArithmeticException</code> if the divisor is zero.
            </p>
            <p class="norm"><a id="jvms-2.11.3-210"></a>
                The Java Virtual Machine does not indicate overflow or underflow during operations
                on floating-point data types. That is, floating-point instructions
                never cause the Java Virtual Machine to throw a run-time exception (not to be confused
                with an IEEE 754 floating-point exception). An operation that overflows
                produces a signed infinity; an operation that underflows produces a
                subnormal value or a signed zero; an operation that has no unique
                mathematically defined result produces NaN. All numeric operations
                with NaN as an operand produce NaN as a result.
            </p>
            <p class="norm"><a id="jvms-2.11.3-300"></a>
                Comparisons on values of type <code class="literal">long</code> (<span
                        class="emphasis"><em>lcmp</em></span>) perform a signed
                comparison.
            </p>
            <p class="norm"><a id="jvms-2.11.3-310"></a>
                Comparisons on values of floating-point types (<span class="emphasis"><em>dcmpg</em></span>, <span
                        class="emphasis"><em>dcmpl</em></span>, <span class="emphasis"><em>fcmpg</em></span>,
                <span class="emphasis"><em>fcmpl</em></span>) are performed using IEEE 754 nonsignaling comparisons.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.4"></a>2.11.4. Type Conversion Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.4-100"></a>
                The type conversion instructions allow conversion between Java Virtual Machine
                numeric types. These may be used to implement explicit conversions in
                user code or to mitigate the lack of orthogonality in the instruction
                set of the Java Virtual Machine.
            </p>
            <p class="norm"><a id="jvms-2.11.4-110"></a>
                The Java Virtual Machine directly supports the following widening numeric
                conversions:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-110-A"></a>
                            <code class="literal">int</code> to <code class="literal">long</code>, <code
                                    class="literal">float</code>, or <code class="literal">double</code>
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-110-B"></a>
                            <code class="literal">long</code> to <code class="literal">float</code> or <code
                                    class="literal">double</code>
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-110-C"></a>
                            <code class="literal">float</code> to <code class="literal">double</code>
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.4-120"></a>
                The widening numeric conversion instructions are <span class="emphasis"><em>i2l</em></span>, <span
                        class="emphasis"><em>i2f</em></span>, <span class="emphasis"><em>i2d</em></span>,
                <span class="emphasis"><em>l2f</em></span>, <span class="emphasis"><em>l2d</em></span>, and <span
                        class="emphasis"><em>f2d</em></span>. The mnemonics for these opcodes are
                straightforward given the naming conventions for typed instructions
                and the punning use of 2 to mean "to." For instance, the <span class="emphasis"><em>i2d</em></span>
                instruction converts an <code class="literal">int</code> value to a <code class="literal">double</code>.
            </p>
            <p class="norm"><a id="jvms-2.11.4-130"></a>
                Most widening numeric conversions do not lose information about the
                overall magnitude of a numeric value. Indeed, conversions widening
                from <code class="literal">int</code> to <code class="literal">long</code> and <code
                        class="literal">int</code> to <code class="literal">double</code> do not lose any information
                at all; the numeric value is preserved exactly. Conversions widening
                from <code class="literal">float</code> to <code class="literal">double</code> also preserve the numeric
                value
                exactly.
            </p>
            <p class="norm"><a id="jvms-2.11.4-140"></a>
                Conversions from <code class="literal">int</code> to <code class="literal">float</code>, or from <code
                        class="literal">long</code> to <code class="literal">float</code>, or from
                <code class="literal">long</code> to <code class="literal">double</code>, may lose <span
                        class="emphasis"><em>precision</em></span>, that is,
                may lose some of the least significant bits of the value; the
                resulting floating-point value is a correctly rounded version of the
                integer value, using the round
                to nearest rounding policy (<a class="xref"
                                               href="./jvms-2.html#jvms-2.8"
                                               title="2.8. Floating-Point Arithmetic">2.8</a>).
            </p>
            <p class="norm"><a id="jvms-2.11.4-150"></a>
                Despite the fact that loss of precision may occur,
                widening numeric conversions never cause the Java Virtual Machine to throw a
                run-time exception (not to be confused with an IEEE 754 floating-point
                exception).
            </p>
            <p class="norm"><a id="jvms-2.11.4-160"></a>A widening numeric
                conversion of an <code class="literal">int</code> to a <code class="literal">long</code> simply
                sign-extends the
                two's-complement representation of the <code class="literal">int</code> value to fill the wider
                format. A widening numeric conversion of a <code class="literal">char</code> to an integral type
                zero-extends the representation of the <code class="literal">char</code> value to fill the wider
                format.
            </p>
            <p class="norm"><a id="jvms-2.11.4-170"></a>
                Note that widening numeric conversions do not exist from integral
                types <code class="literal">byte</code>, <code class="literal">char</code>, and <code
                        class="literal">short</code> to type <code class="literal">int</code>. As noted in
                <a class="xref" href="./jvms-2.html#jvms-2.11.1"
                   title="2.11.1. Types and the Java Virtual Machine">2.11.1</a>, values of type <code
                        class="literal">byte</code>, <code class="literal">char</code>, and
                <code class="literal">short</code> are internally widened to type <code class="literal">int</code>,
                making these
                conversions implicit.
            </p>
            <p class="norm"><a id="jvms-2.11.4-200"></a>The Java Virtual Machine also directly
                supports the following narrowing numeric conversions:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-200-A"></a>
                            <code class="literal">int</code> to <code class="literal">byte</code>, <code
                                    class="literal">short</code>, or <code class="literal">char</code>
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-200-B"></a>
                            <code class="literal">long</code> to <code class="literal">int</code>
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-200-C"></a>
                            <code class="literal">float</code> to <code class="literal">int</code> or <code
                                    class="literal">long</code>
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-200-D"></a>
                            <code class="literal">double</code> to <code class="literal">int</code>, <code
                                    class="literal">long</code>, or <code class="literal">float</code>
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.4-210"></a>
                The narrowing numeric conversion instructions are <span class="emphasis"><em>i2b</em></span>, <span
                        class="emphasis"><em>i2c</em></span>,
                <span class="emphasis"><em>i2s</em></span>, <span class="emphasis"><em>l2i</em></span>, <span
                        class="emphasis"><em>f2i</em></span>, <span class="emphasis"><em>f2l</em></span>, <span
                        class="emphasis"><em>d2i</em></span>, <span class="emphasis"><em>d2l</em></span>, and <span
                        class="emphasis"><em>d2f</em></span>.
                A narrowing numeric conversion can result in a value of
                different sign, a different order of magnitude, or both; it
                may thereby lose precision.
            </p>
            <p class="norm"><a id="jvms-2.11.4-220"></a>
                A narrowing numeric conversion of an <code class="literal">int</code> or <code
                        class="literal">long</code> to an
                integral type <span class="type">T</span> simply discards all but the <span
                        class="emphasis"><em>n</em></span> lowest-order
                bits, where <span class="emphasis"><em>n</em></span> is the number of bits used to represent type <span
                        class="type">T</span>.
                This may cause the resulting value not to have the same sign as
                the input value.
            </p>
            <p class="norm"><a id="jvms-2.11.4-230"></a>
                In a narrowing numeric conversion of a floating-point value to an
                integral type <span class="type">T</span>, where <span class="type">T</span> is either <code
                        class="literal">int</code> or <code class="literal">long</code>,
                the floating-point value is converted as follows:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-230-A"></a>
                            If the floating-point value is NaN, the result of the
                            conversion is an <code class="literal">int</code> or <code class="literal">long</code> <code
                                    class="literal">0</code>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-230-B"></a>
                            Otherwise, if the floating-point value is not an infinity,
                            the floating-point value is rounded to an integer value
                            <span class="type">V</span> using the round
                            toward zero rounding policy (<a class="xref"
                                                            href="./jvms-2.html#jvms-2.8"
                                                            title="2.8. Floating-Point Arithmetic">2.8</a>).
                            There are two cases:
                        </p>
                        <div class="norm">
                            <ul class="norm" style="list-style-type: circle; ">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-2.11.4-230-B-A"></a>
                                        If <span class="type">T</span> is <code class="literal">long</code> and this
                                        integer
                                        value can be represented
                                        as a <code class="literal">long</code>, then the result is the <code
                                                class="literal">long</code> value <span class="type">V</span>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-2.11.4-230-B-B"></a>
                                        If <span class="type">T</span> is of type <code class="literal">int</code> and
                                        this
                                        integer value can be
                                        represented as an <code class="literal">int</code>, then the result is the <code
                                                class="literal">int</code>
                                        value <span class="type">V</span>.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.4-230-C"></a>
                            Otherwise:
                        </p>
                        <div>
                            <ul style="list-style-type: circle; ">
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-2.11.4-230-C-A"></a>
                                        Either the value must be too small (a negative value of
                                        large magnitude or negative infinity), and the result
                                        is the smallest representable value of type <code class="literal">int</code>
                                        or <code class="literal">long</code>.
                                    </p>
                                </li>
                                <li class="listitem">
                                    <p class="norm"><a id="jvms-2.11.4-230-C-B"></a>
                                        Or the value must be too large (a positive value of
                                        large magnitude or positive infinity), and the result
                                        is the largest representable value of type <code class="literal">int</code>
                                        or <code class="literal">long</code>.
                                    </p>
                                </li>
                            </ul>
                        </div>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.4-240"></a>
                A narrowing numeric conversion from <code class="literal">double</code> to <code
                        class="literal">float</code> behaves in
                accordance with IEEE 754. The result is correctly rounded using
                the round to nearest rounding
                policy (<a class="xref" href="./jvms-2.html#jvms-2.8"
                           title="2.8. Floating-Point Arithmetic">2.8</a>). A value too small to be
                represented as a <code class="literal">float</code> is converted to a positive or negative
                zero of type <code class="literal">float</code>; a value too large to be represented as a
                <code class="literal">float</code> is converted to a positive or negative infinity.
                A <code class="literal">double</code> NaN is always converted to a <code class="literal">float</code>
                NaN.
            </p>
            <p class="norm"><a id="jvms-2.11.4-300"></a>
                Despite the fact that overflow, underflow, or loss of precision
                may occur, narrowing conversions among numeric types never cause
                the Java Virtual Machine to throw a run-time exception (not to be confused with
                an IEEE 754 floating-point exception).
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.5"></a>2.11.5. Object Creation and Manipulation
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.5-100"></a>Although both class
                instances and arrays are objects, the Java Virtual Machine creates and manipulates
                class instances and arrays using distinct sets of instructions:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-A"></a>
                            Create a new class instance: <span class="emphasis"><em>new</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-B"></a>
                            Create a new array: <span class="emphasis"><em>newarray</em></span>, <span
                                    class="emphasis"><em>anewarray</em></span>, <span
                                    class="emphasis"><em>multianewarray</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-C"></a>
                            Access fields of classes (<code class="literal">static</code> fields, known as class
                            variables) and fields of class instances (non-<code class="literal">static</code> fields,
                            known as instance variables):
                            <span class="emphasis"><em>getstatic</em></span>, <span
                                    class="emphasis"><em>putstatic</em></span>, <span class="emphasis"><em>getfield</em></span>,
                            <span class="emphasis"><em>putfield</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-D"></a>
                            Load an array component onto the operand stack: <span
                                    class="emphasis"><em>baload</em></span>,
                            <span class="emphasis"><em>caload</em></span>, <span class="emphasis"><em>saload</em></span>,
                            <span class="emphasis"><em>iaload</em></span>, <span class="emphasis"><em>laload</em></span>,
                            <span class="emphasis"><em>faload</em></span>, <span class="emphasis"><em>daload</em></span>,
                            <span class="emphasis"><em>aaload</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-E"></a>
                            Store a value from the operand stack as an array component:
                            <span class="emphasis"><em>bastore</em></span>, <span
                                    class="emphasis"><em>castore</em></span>,
                            <span class="emphasis"><em>sastore</em></span>, <span
                                    class="emphasis"><em>iastore</em></span>,
                            <span class="emphasis"><em>lastore</em></span>,
                            <span class="emphasis"><em>fastore</em></span>, <span
                                    class="emphasis"><em>dastore</em></span>,
                            <span class="emphasis"><em>aastore</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-F"></a>
                            Get the length of array: <span class="emphasis"><em>arraylength</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.5-100-G"></a>
                            Check properties of class instances or arrays: <span
                                    class="emphasis"><em>instanceof</em></span>,
                            <span class="emphasis"><em>checkcast</em></span>.
                        </p>
                    </li>
                </ul>
            </div>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.6"></a>2.11.6. Operand Stack Management Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.6-100"></a>A number of instructions
                are provided for the direct manipulation of the operand stack: <span
                        class="emphasis"><em>pop</em></span>,
                <span class="emphasis"><em>pop2</em></span>, <span class="emphasis"><em>dup</em></span>, <span
                        class="emphasis"><em>dup2</em></span>, <span class="emphasis"><em>dup_x1</em></span>, <span
                        class="emphasis"><em>dup2_x1</em></span>, <span class="emphasis"><em>dup_x2</em></span>, <span
                        class="emphasis"><em>dup2_x2</em></span>,
                <span class="emphasis"><em>swap</em></span>.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.7"></a>2.11.7. Control Transfer Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.7-100"></a>The control transfer
                instructions conditionally or unconditionally cause the Java Virtual Machine to
                continue execution with an instruction other than the one following
                the control transfer instruction. They are:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.7-100-A"></a>Conditional branch:
                            <span class="emphasis"><em>ifeq</em></span>, <span class="emphasis"><em>ifne</em></span>,
                            <span
                                    class="emphasis"><em>iflt</em></span>, <span class="emphasis"><em>ifle</em></span>,
                            <span
                                    class="emphasis"><em>ifgt</em></span>, <span class="emphasis"><em>ifge</em></span>,
                            <span
                                    class="emphasis"><em>ifnull</em></span>,
                            <span class="emphasis"><em>ifnonnull</em></span>, <span
                                    class="emphasis"><em>if_icmpeq</em></span>, <span
                                    class="emphasis"><em>if_icmpne</em></span>,
                            <span class="emphasis"><em>if_icmplt</em></span>, <span
                                    class="emphasis"><em>if_icmple</em></span>,
                            <span class="emphasis"><em>if_icmpgt</em></span> <span
                                    class="emphasis"><em>if_icmpge</em></span>, <span
                                    class="emphasis"><em>if_acmpeq</em></span>,
                            <span class="emphasis"><em>if_acmpne</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.7-100-B"></a>Compound conditional
                            branch: <span class="emphasis"><em>tableswitch</em></span>, <span
                                    class="emphasis"><em>lookupswitch</em></span>.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.7-100-C"></a>Unconditional branch:
                            <span class="emphasis"><em>goto</em></span>, <span class="emphasis"><em>goto_w</em></span>,
                            <span class="emphasis"><em>jsr</em></span>, <span class="emphasis"><em>jsr_w</em></span>,
                            <span
                                    class="emphasis"><em>ret</em></span>.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.7-110"></a>The Java Virtual Machine has distinct sets
                of instructions that conditionally branch on comparison with data of
                <code class="literal">int</code> and <code class="literal">reference</code> types. It also has distinct
                conditional branch
                instructions that test for the null reference and thus it is not
                required to specify a concrete value for <code class="literal">null</code>
                (<a class="xref" href="./jvms-2.html#jvms-2.4"
                    title="2.4. Reference Types and Values">2.4</a>).
            </p>
            <p class="norm"><a id="jvms-2.11.7-120"></a>Conditional branches on
                comparisons between data of types <code class="literal">boolean</code>, <code
                        class="literal">byte</code>, <code class="literal">char</code>, and
                <code class="literal">short</code> are performed using <code class="literal">int</code> comparison
                instructions
                (<a class="xref" href="./jvms-2.html#jvms-2.11.1"
                    title="2.11.1. Types and the Java Virtual Machine">2.11.1</a>). A conditional branch on a comparison
                between data of types <code class="literal">long</code>, <code class="literal">float</code>, or <code
                        class="literal">double</code> is initiated using
                an instruction that compares the data and produces an <code class="literal">int</code> result of
                the comparison (<a class="xref"
                                   href="./jvms-2.html#jvms-2.11.3"
                                   title="2.11.3. Arithmetic Instructions">2.11.3</a>). A subsequent <code
                        class="literal">int</code>
                comparison instruction tests this result and effects the conditional
                branch. Because of its emphasis on <code class="literal">int</code> comparisons, the Java Virtual
                Machine
                provides a rich complement of conditional branch instructions for type
                <code class="literal">int</code>.
            </p>
            <p class="norm"><a id="jvms-2.11.7-130"></a>All <code class="literal">int</code> conditional
                control transfer instructions perform signed comparisons.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.8"></a>2.11.8. Method Invocation and Return Instructions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.8-100"></a>
                The following five instructions invoke methods:
            </p>
            <div class="norm">
                <ul class="norm" style="list-style-type: disc; ">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.8-100-A"></a>
                            <span class="emphasis"><em>invokevirtual</em></span> invokes an instance method of an
                            object,
                            dispatching on the (virtual) type of the object. This is the
                            normal method dispatch in the Java programming language.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.8-100-B"></a>
                            <span class="emphasis"><em>invokeinterface</em></span> invokes an interface method,
                            searching
                            the
                            methods implemented by the particular run-time object to find
                            the appropriate method.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.8-100-C"></a>
                            <span class="emphasis"><em>invokespecial</em></span> invokes an instance method requiring
                            special
                            handling, either an instance
                            initialization method (<a class="xref"
                                                      href="./jvms-2.html#jvms-2.9.1"
                                                      title="2.9.1. Instance Initialization Methods">2.9.1</a>) or a
                            method
                            of the current class or its supertypes.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.8-100-D"></a>
                            <span class="emphasis"><em>invokestatic</em></span> invokes a class (<code
                                    class="literal">static</code>) method in a named
                            class.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.8-100-E"></a>
                            <span class="emphasis"><em>invokedynamic</em></span> invokes the method which is the target
                            of
                            the
                            call site object bound to the <span class="emphasis"><em>invokedynamic</em></span>
                            instruction.
                            The
                            call site object was bound to a specific lexical occurrence of
                            the <span class="emphasis"><em>invokedynamic</em></span> instruction by the Java Virtual
                            Machine
                            as a result of
                            running a bootstrap method before the first execution of the
                            instruction. Therefore, each occurrence of an <span
                                    class="emphasis"><em>invokedynamic</em></span>
                            instruction has a unique linkage state, unlike the other
                            instructions which invoke methods.
                        </p>
                    </li>
                </ul>
            </div>
            <p class="norm"><a id="jvms-2.11.8-200"></a>
                The method return instructions, which are distinguished by return
                type, are <span class="emphasis"><em>ireturn</em></span> (used to return values of type <code
                        class="literal">boolean</code>, <code class="literal">byte</code>,
                <code class="literal">char</code>, <code class="literal">short</code>, or <code
                        class="literal">int</code>), <span class="emphasis"><em>lreturn</em></span>, <span
                        class="emphasis"><em>freturn</em></span>, <span class="emphasis"><em>dreturn</em></span>, and
                <span class="emphasis"><em>areturn</em></span>. In addition, the <span
                        class="emphasis"><em>return</em></span> instruction is used to return
                from methods declared to be void, instance initialization methods, and
                class or interface initialization methods.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.9"></a>2.11.9. Throwing Exceptions
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.9-100"></a>An exception is thrown
                programmatically using the <span class="emphasis"><em>athrow</em></span> instruction. Exceptions can
                also
                be thrown by various Java Virtual Machine instructions if they detect an abnormal
                condition.
            </p>
        </div>
        <div class="section">
            <div class="titlepage">
                <div>
                    <div>
                        <h3 class="title"><a id="jvms-2.11.10"></a>2.11.10. Synchronization
                        </h3>
                    </div>
                </div>
            </div>
            <p class="norm"><a id="jvms-2.11.10-100"></a>The Java Virtual Machine supports
                synchronization of both methods and sequences of instructions within a
                method by a single synchronization construct:
                the <span class="emphasis"><em>monitor</em></span>.
            </p>
            <p class="norm"><a id="jvms-2.11.10-110"></a>Method-level
                synchronization is performed implicitly, as part of method invocation
                and return (<a class="xref"
                               href="./jvms-2.html#jvms-2.11.8"
                               title="2.11.8. Method Invocation and Return Instructions">2.11.8</a>). A <code
                        class="literal">synchronized</code> method is
                distinguished in the run-time constant pool's <code class="literal">method_info</code> structure
                (<a class="xref" href="./jvms-4.html#jvms-4.6"
                    title="4.6. Methods">4.6</a>) by the <code class="literal">ACC_SYNCHRONIZED</code> flag, which is
                checked by the method invocation instructions. When invoking a method
                for which <code class="literal">ACC_SYNCHRONIZED</code> is set, the executing thread enters a
                monitor, invokes the method itself, and exits the monitor whether the
                method invocation completes normally or abruptly. During the time the
                executing thread owns the monitor, no other thread may enter it. If an
                exception is thrown during invocation of the <code class="literal">synchronized</code> method and
                the <code class="literal">synchronized</code> method does not handle the exception, the monitor
                for the method is automatically exited before the exception is
                rethrown out of the <code class="literal">synchronized</code> method.
            </p>
            <p class="norm"><a id="jvms-2.11.10-120"></a>Synchronization of
                sequences of instructions is typically used to encode the
                <code class="literal">synchronized</code> block of the Java programming language. The Java Virtual
                Machine supplies the
                <span class="emphasis"><em>monitorenter</em></span> and <span
                        class="emphasis"><em>monitorexit</em></span> instructions to support such language
                constructs. Proper implementation of <code class="literal">synchronized</code> blocks requires
                cooperation from a compiler targeting the Java Virtual Machine
                (<a class="xref" href="./jvms-3.html#jvms-3.14"
                    title="3.14. Synchronization">3.14</a>).
            </p>
            <p class="norm"><a id="jvms-2.11.10-200"></a><span class="emphasis"><em>Structured
                     locking</em></span> is the situation when, during a method invocation,
                every exit on a given monitor matches a preceding entry on that
                monitor. Since there is no assurance that all code submitted to the
                Java Virtual Machine will perform structured locking, implementations of the Java Virtual Machine
                are permitted but not required to enforce both of the following two
                rules guaranteeing structured locking. Let <span class="emphasis"><em>T</em></span> be a
                thread and <span class="emphasis"><em>M</em></span> be a monitor. Then:
            </p>
            <div class="orderedlist">
                <ol class="orderedlist" type="1">
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.10-200-A"></a>
                            The number of monitor entries performed
                            by <span class="emphasis"><em>T</em></span> on <span class="emphasis"><em>M</em></span>
                            during a
                            method invocation must equal the number of monitor exits
                            performed by <span class="emphasis"><em>T</em></span> on <span
                                    class="emphasis"><em>M</em></span>
                            during the method invocation whether the method invocation
                            completes normally or abruptly.
                        </p>
                    </li>
                    <li class="listitem">
                        <p class="norm"><a id="jvms-2.11.10-200-B"></a>
                            At no point during a method invocation may the number of monitor
                            exits performed by <span class="emphasis"><em>T</em></span>
                            on <span class="emphasis"><em>M</em></span> since the method invocation exceed the
                            number of monitor entries performed by <span class="emphasis"><em>T</em></span>
                            on <span class="emphasis"><em>M</em></span> since the method invocation.
                        </p>
                    </li>
                </ol>
            </div>
            <p class="norm"><a id="jvms-2.11.10-210"></a>Note that the monitor
                entry and exit automatically performed by the Java Virtual Machine when invoking a
                <code class="literal">synchronized</code> method are considered to occur during the calling
                method's invocation.
            </p>
        </div>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.12"></a>2.12. Class Libraries
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.12-100"></a>The Java Virtual Machine must provide
            sufficient support for the implementation of the class libraries of
            the Java SE Platform. Some of the classes in
            these libraries cannot be implemented without the cooperation of the
            Java Virtual Machine.
        </p>
        <p class="norm"><a id="jvms-2.12-110"></a>Classes that might require
            special support from the Java Virtual Machine include those that support:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-A"></a>Reflection, such as the
                        classes in the package <code class="literal">java.lang.reflect</code> and
                        the class <code class="literal">Class</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-B"></a>Loading and creation of
                        a class or interface. The most obvious example is the class
                        <code class="literal">ClassLoader</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-C"></a>Linking and
                        initialization of a class or interface. The example classes cited
                        above fall into this category as well.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-D"></a>Security, such as the
                        classes in the package <code class="literal">java.security</code> and other
                        classes such as <code class="literal">SecurityManager</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-E"></a>Multithreading, such as
                        the class <code class="literal">Thread</code>.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.12-110-F"></a>Weak references, such
                        as the classes in the
                        package <code class="literal">java.lang.ref</code>.
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.12-120"></a>The list above is meant to be
            illustrative rather than comprehensive. An exhaustive list of these
            classes or of the functionality they provide is beyond the scope of
            this specification. See the specifications of the Java SE Platform class
            libraries for details.
        </p>
    </div>
    <div class="section">
        <div class="titlepage">
            <div>
                <div>
                    <h2 class="title" style="clear: both"><a id="jvms-2.13"></a>2.13. Public Design, Private
                        Implementation
                    </h2>
                </div>
            </div>
        </div>
        <p class="norm"><a id="jvms-2.13-100"></a>Thus far this specification
            has sketched the public view of the Java Virtual Machine: the <code class="literal">class</code> file format
            and
            the instruction set. These components are vital to the hardware-,
            operating system-, and implementation-independence of the Java Virtual Machine. The
            implementor may prefer to think of them as a means to securely
            communicate fragments of programs between hosts each implementing the
            Java SE Platform, rather than as a blueprint to be followed exactly.
        </p>
        <p class="norm"><a id="jvms-2.13-110"></a>It is important to understand
            where the line between the public design and the private
            implementation lies. A Java Virtual Machine implementation must be able to read
            <code class="literal">class</code> files and must exactly implement the semantics of the Java Virtual
            Machine
            code therein. One way of doing this is to take this document as a
            specification and to implement that specification literally. But it is
            also perfectly feasible and desirable for the implementor to modify or
            optimize the implementation within the constraints of this
            specification. So long as the <code class="literal">class</code> file format can be read and the
            semantics of its code are maintained, the implementor may implement
            these semantics in any way. What is "under the hood" is the
            implementor's business, as long as the correct external interface is
            carefully maintained.
        </p>
        <p class="note">There are some exceptions: debuggers, profilers, and
            just-in-time code generators can each require access to elements of
            the Java Virtual Machine that are normally considered to be under the hood. Where
            appropriate, Oracle works with other Java Virtual Machine implementors and with tool
            vendors to develop common interfaces to the Java Virtual Machine for use by such
            tools, and to promote those interfaces across the industry.
        </p>
        <p class="norm"><a id="jvms-2.13-120"></a>The implementor can use this
            flexibility to tailor Java Virtual Machine implementations for high performance, low
            memory use, or portability. What makes sense in a given implementation
            depends on the goals of that implementation. The range of
            implementation options includes the following:
        </p>
        <div class="norm">
            <ul class="norm" style="list-style-type: disc; ">
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.13-120-A"></a>Translating Java Virtual Machine code
                        at load-time or during execution into the instruction set of
                        another virtual machine.
                    </p>
                </li>
                <li class="listitem">
                    <p class="norm"><a id="jvms-2.13-120-B"></a>Translating Java Virtual Machine code
                        at load-time or during execution into the native instruction set
                        of the host CPU (sometimes referred to
                        as <span class="emphasis"><em>just-in-time</em></span>, or <span
                                class="emphasis"><em>JIT</em></span>,
                        code generation).
                    </p>
                </li>
            </ul>
        </div>
        <p class="norm"><a id="jvms-2.13-130"></a>The existence of a precisely
            defined virtual machine and object file format need not significantly
            restrict the creativity of the implementor. The Java Virtual Machine is designed to
            support many different implementations, providing new and interesting
            solutions while retaining compatibility between
            implementations.
        </p>
    </div>
</div>
<div class="navfooter">
    <hr/>
    <table width="100%" summary="Navigation footer">
        <tbody>
        <tr>
            <td width="40%" align="left"><a accesskey="p"
                                            href="./jvms-1.html">Prev</a>
            </td>
            <td width="20%" align="center"></td>
            <td width="40%" align="right"><a accesskey="n"
                                             href="./jvms-3.html">Next</a></td>
        </tr>
        <tr>
            <td width="40%" align="left" valign="top">Chapter 1. Introduction</td>
            <td width="20%" align="center"><a accesskey="h"
                                              href="./index.html">Home</a></td>
            <td width="40%" align="right" valign="top"> Chapter 3. Compiling for the Java Virtual
                Machine
            </td>
        </tr>
        </tbody>
    </table>
</div>

</body>

</html>