---
title: "调优：内存泄漏"
sequence: "102"
---

## 何为内存泄漏

可达性分析算法来判断对象是否是不再使用的对象，本质上都是判断一个对象是否还被引用。
那么，对于这种情况下，由于代码的实现不同，就会出现很多种内存泄漏问题
（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）

严格来说，**只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏**。
但实际情况很多时候一些不好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，
也可以叫做宽泛意义上的“内存泄漏”。

## 内在泄漏与内存溢出

内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。

## 内存泄漏的分类

- 经常发生：发生内存泄漏的代码会被执行很多次，每次执行，泄漏一块内存。
- 偶然发生：在某些特定情况下才会发生
- 一次性：发生内存泄漏的方法只会执行一次
- 隐式泄漏：一直占着内存不释放，直到执行结束；严格的说，这个不算内存泄漏，因为最终释放掉了。但是，如果执行时间特别长，也可能会导致内存耗尽。

## 内存泄漏的八种情况

内存泄漏的八种情况：

- 静态集合类
- 单例模式
- 内在类持有外部类
- 各种连接，如数据库连接、网络连接和IO连接等
- 变量不合理的作用域
- 改变哈希值
- 缓存泄漏
- 监听器和回调

### 静态集合类

静态集合类，如`HashMap`、`LinkedList`等。
如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。
简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，
但是因为长生命周期对象持有它的引用而导致不能被回收。

```java
import java.util.ArrayList;
import java.util.List;

public class HelloWorld {
    private static List<Object> list = new ArrayList<>();

    public void test() {
        Object obj = new Object();
        list.add(obj);
    }
}
```

### 单例模式

单例模式，和静态集合导致内存泄漏的原因类似。
因为单例的静态特性，它的生命周期和JVM的生命周期一样长，
所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，
那么就会造成内存泄漏。

### 内部类持有外部类

内部类持有外部类，如果一个外部类的实例对象的方法返回一个内部类的实例对象。
这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，
但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。

### 各种连接

各种连接，如数据库连接、网络连接和IO连接等。

在对数据库进行操作的过程中，首先需要建立与数据库的连接；
当不再使用时，需要调用`close()`方法来释放与数据库的连接。
只有连接被关闭后，垃圾回收器才会回收对应的对象。

否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，
将会造成大量的对象无法回收，从而引起内存泄漏。

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class HelloWorld {
    public void test() {
        try {
            Connection conn = null;
            Class.forName("com.mysql.jdbc.Driver");
            conn = DriverManager.getConnection("url", "", "");
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery("...");
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
        finally {
            // 1. 关闭结果集ResultSet
            // 2. 关闭声明对象Statement
            // 3. 关闭连接Connection
        }
    }
}
```

### 变量不合理的作用域

变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能造成内存泄漏。
另一方面，如果没有及时把对象设置为null，很有可能导致内存泄漏的发生。

```java
public class HelloWorld {
    private String msg;
    public void test() {
        readFromNet(); // 从网络中接收数据保存到msg中
        saveDB(); // 把msg保存到数据库中
    }
}
```

如上面这个伪代码，通过`readFromNet()`方法把接收到的消息保存在变量`msg`中，
然后调用`saveDB()`方法把`msg`的内容保存到数据库中，此时`msg`已经就没有用了。
由于`msg`的生命周期与对象的生命周期相同，此时`msg`还不能回收，因此造成内存泄漏。

实际上，这个`msg`变量可以放在`test()`方法内部，当方法使用完，那么`msg`的生命周期也就结束了，
此时就可以回收了。
还有一种办法，在使用完`msg`后，把`msg`设置成`null`，这样垃圾回收器也会回收。

### 改变哈希值

改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。
否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了；
在这种情况下，即使在`contains`方法使用该对象的当前引用作为参数去HashSet集合中检索对象，
也将返回不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。

这也是`String`为什么被设置成了不可变类型，我们可以放心地把`String`存入HashSet，或者把`String`当做HashMap的Key值。

### 缓存泄漏

内存泄漏的另一个常见来源是缓存。一旦把对象引入缓存中，它就很容易被遗忘。
比如，之前项目在一次上线的时候，应用启动奇慢，就是因为代码中会加载一个表中的数据到缓存（内存）中，
测试环境只有几百条数据，但是生产环境有几百万的数据。

对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，
此key没有其他引用，那么此map会自动丢弃此值。

### 监听器和回调

内存泄漏又一个常见的来源是监听器和回调。
如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。

需要确保回调立即被当作垃圾回收的最佳操作是只保存它的弱引用，
例如将他们保存成为WeakHashMap中的键。

## 检测内存泄漏

jstat可以用来判断是否出现内存泄漏。

第一步，在长时间运行的Java程序中，我们可以运行`jstat`命令连续获取多行性能数据，
并取这几数据中OU列（即老年代占用的内存空间）的最小值。

第二步，每隔一段较长的时间重复上一次操作，来获得多组OU最小值。
如果这些值呈现上涨趋势，则说明该Java程序的老年代内存已经使用量在不断上涨，
这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。


