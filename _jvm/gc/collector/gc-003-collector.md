---
title: "GC 收集器"
sequence: "103"
---

首先要理解以下两个概念：

（1）**单线程**和**多线程**：

- 垃圾收集器只使用一个线程就说垃圾收集器是单线程的
- 垃圾收集器使用多个线程就说垃圾收集器是多线程

（2）**串行**和**并行**：

- 串行指的是垃圾收集器和用户程序交替执行(执行垃圾收集器的时候需要停止用户程序，即用户现线程和GC线程交替执行），
- 并行是指垃圾收集器和用户程序同时执行(也就是执行垃圾收集器的时候不需要停止用户程序，即用户线程和GC线程可以一起执行）


## GC 收集器

- 分代收集器
    - 年轻代：Serial、ParNew、Parallel Scavenge（默认）
    - 老年代：CMS、SerialOld（默认）、ParallelOld
- 不分代收集器：G1、ZGC、Shenandoah

![](/assets/images/java/jvm/jvm-gc-collector.png)

使用情况：

- 如果年轻代使用了 Serial，老年代只能使用 CMS、SerialOld

## 三种年轻代 GC 收集器

### Serial

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器，是一个单线程收集器(也就是它只会使用一个垃圾收集线程去完成垃圾收集工作）

它在进行垃圾收集工作的时候，必须暂停其它所有的工作线程（ "Stop The World" ），直到它收集结束

Serial：垃圾回收线程只有一个，而且垃圾回收线程工作的时候其它用户线程要停下来

Serial 垃圾回收器在回收垃圾的时候，新生代采用标记-复制算法，老年代采用标记-整理算法。

Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率

![](/assets/images/java/jvm/jvm-gc-yong-serial.png)

### ParNew

ParNew：Serial 的多线程版本，有多个垃圾回收线程，垃圾回收线程工作的时候，其它用户线程要停下来

![](/assets/images/java/jvm/jvm-gc-yong-par-new.png)

### PS

Parallel Scavenge：多个垃圾回收线程，垃圾线程工作的时候其它用户线程需要停止工作，跟 ParNew 很像。
可以设置参数：垃圾收集导致最大停顿时间和设置吞吐量的大小。
通过 GC 自适应调节策略(虚拟机会根据系统的运行状况动态地设置参数)来达到目标停顿时间和吞吐量。
特点是获取最大吞吐量（一共运行 100 分钟，垃圾回收器花掉 3 分钟，吞吐量就是 97%）

![](/assets/images/java/jvm/jvm-gc-yong-parallel-scavenge.png)

## 三种老年代收集器

### SerialOld

![](/assets/images/java/jvm/jvm-gc-old-serial-old.png)

### Parallel Old

![](/assets/images/java/jvm/jvm-gc-old-parallel-old.png)

### CMS

CMS：第一款实现垃圾收集线程和用户线程同时工作的垃圾回收器，第一款并发收集器，目的是追求最短停顿时间（垃圾回收线程工作导致用户线程停顿的时间）

CMS 垃圾回收器工作的的四个阶段：在初始标记和重新标记阶段只能有垃圾回收线程在工作，用户线程需要停止，其它两个阶段垃圾回收线程和用户线程可以同时工作

（1）初始标记：标记和 GC Root 直接相连的对象，这个阶段很快，但是这个阶段其它用户线程无法工作，还是会发生 stop the world（STW）

（2）并发标记：CMS 线程会从与 GC Roots 直接相连的对象出发，遍历所有对象，标记所有存活的对象，这个阶段，CMS 线程和其它用户线程在并发执行

（3）重新标记：并发标记阶段由于 CMS 线程和其它用户线程并行运行，所以其它用户线程可能产生一些新的对象，这些新对象还没有打上是否存活的标记，
所以需要标记出这些新对象中存活的对象，这个过程是只有 CMS 线程，用户线程需要停止工作，所以这个过程会引起 STW

（4）并发清除：清除那些没有标记存活的对象，然后最后将这些对象的标记取消

助记：三个标记阶段，一个清除阶段

缺点：这种标记清除的回收方式会产生内存碎片

虽然 STW 时间很短，但是没法预测，G1 就建立了一个预测模型

追求最短的停顿时间（STW），分为四个阶段：初始标记，并发标记，重新标记，并发清理，
只有初始标记阶段和重新标记阶段需要暂停用户线程，其它阶段不需要暂停用户线程，可以和用户线程并行，
所以适用于暂停时间要求比较高的，比如实时系统，交互式系统

整个过程分为以下几个步骤：

（1）初始标记：标记直接与 root 相连的对象 （不直接相连，间接相连的不标记)，这是一个 STW（stop the world）阶段，其它用户线程是不能工作的

（2）并发标记：CMS线程会从与GC Roots直接相连的对象出发，遍历整个对象图，标记所有存活的对象，这个阶段，CMS线程和其它用户线程在并发执行，

（3）重新标记： 由于上一个阶段并发标记阶段其它用户线程实际上还是在运行的，有可能用户线程在这个阶段产生了新的对象（这些新的对象中的存活对象是没有打上标记的）,这里采用三色标记法来标记那些新产生的对象中存活对象

（4）并发清理：清除所有没有被标记的对象，这个阶段如果有新增对象会被标记为黑色，不做任何处理

最后并发重置就是把 标记过的对象取消标记

三色标记算法：

黑色：这个对象及其所有的引用的对象都被遍历过，那这个对象就是黑色，黑色的对象不会被回收

灰色：这个对象被遍历过，但是它的部分引用还没被遍历过，在重新标记阶段会将这个对象标记为灰色

白色：这个对象没有被遍历过，在重新标记阶段如果是白色的话，这个对象将被回收


![](/assets/images/java/jvm/jvm-gc-old-cms.png)

## 总结

Serial 单个垃圾回收线程执行(单线程)，其它所有用户线程都要停下来；
Serial 是用于新生代的垃圾回收器，它的老年代版本是Serial old。
