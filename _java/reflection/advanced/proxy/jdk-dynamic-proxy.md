---
title: "JDK Dynamic Proxy"
sequence: "101"
---

## Proxy

```text
                          ┌─── getProxyClass(ClassLoader loader, Class<?>... interfaces)
         ┌─── class ──────┤
         │                └─── isProxyClass(Class<?> cl)
         │
Proxy ───┼─── instance ───┼─── newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
         │
         │
         └─── handler ────┼─── getInvocationHandler(Object proxy)
```

### 概念

A **proxy class** is a class created at runtime that implements a specified list of interfaces, known as **proxy interfaces**.

> proxy class, proxy interfaces

A **proxy instance** is an instance of a proxy class.

> proxy instance

Each **proxy instance** has an associated **invocation handler** object, which implements the interface `InvocationHandler`.

> proxy instance --> invocation handler

A **method invocation** on a **proxy instance** through one of its proxy interfaces
will be dispatched to the `invoke` method of the instance's invocation handler,
passing the proxy instance, a `java.lang.reflect.Method` object identifying the method that was invoked,
and an array of type `Object` containing the arguments.

> invocation handler --> invoke method

```java
public interface InvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

The **invocation handler** processes the encoded method invocation as appropriate and
the result that it returns will be returned as the result of the **method invocation** on the **proxy instance**.

## Proxy Class 特性

A proxy class has the following properties:

### 访问标识

- Proxy classes are `public`, `final`, and not abstract if all proxy interfaces are public.
- Proxy classes are non-public, final, and not abstract if any of the proxy interfaces is non-public.

### 类名

- The unqualified name of a proxy class is unspecified.
  The space of class names that begin with the string "$Proxy" should be, however, reserved for proxy classes.

### 类继承关系

- A proxy class extends `java.lang.reflect.Proxy`.
- A proxy class implements exactly the interfaces specified at its creation, in the same order.

### 包

- If a proxy class implements a non-public interface, then it will be defined in the same package as that interface.
- Otherwise, the package of a proxy class is also unspecified.

Note that package sealing will not prevent a proxy class
from being successfully defined in a particular package at runtime,
and neither will classes already defined by the same class loader and the same package with particular signers.

### Constructor

Each proxy class has one public constructor that takes one argument,
an implementation of the interface `InvocationHandler`,
to set the invocation handler for a proxy instance.

Rather than having to use the reflection API to access the public constructor,
a proxy instance can be also be created by calling the `Proxy.newProxyInstance` method,
which combines the actions of calling `Proxy.getProxyClass` with invoking the constructor with an invocation handler.

```text
Proxy.newProxyInstance = Proxy.getProxyClass + invoke the constructor with an invocation handler
```

### 反射

Since a proxy class implements all of the interfaces specified at its creation,
invoking `getInterfaces` on its `Class` object will return an array containing the same list of interfaces
(in the order specified at its creation).

Invoking `getMethods` on its `Class` object will return an array of `Method` objects
that include all of the methods in those interfaces.

Invoking `getMethod` will find methods in the proxy interfaces as would be expected.

### Proxy Class

- The `Proxy.isProxyClass` method will return `true` if it is passed a proxy class--
  a class returned by `Proxy.getProxyClass` or the class of an object returned by `Proxy.newProxyInstance`-- and `false` otherwise.

### Security

The `java.security.ProtectionDomain` of a proxy class is the same as
that of system classes loaded by the bootstrap class loader, such as `java.lang.Object`,
because the code for a proxy class is generated by trusted system code.
This protection domain will typically be granted `java.security.AllPermission`.

## Proxy Instance 特性

A proxy instance has the following properties:

### 类与实例

Given a proxy instance `proxy` and one of the interfaces implemented by its proxy class `Foo`, the following expression will return true:

```text
proxy instanceof Foo
```

and the following cast operation will succeed (rather than throwing a ClassCastException):

```text
(Foo) proxy
```

### invocation handler

Each proxy instance has an associated invocation handler, the one that was passed to its constructor.
The static `Proxy.getInvocationHandler` method will return the invocation handler associated with the proxy instance passed as its argument.

### 方法调用

An interface method invocation on a proxy instance will be encoded and
dispatched to the invocation handler's `invoke` method as described in the documentation for that method.

### Object 方法

An invocation of the `hashCode`, `equals`, or `toString` methods declared in `java.lang.Object` on a proxy instance
will be encoded and dispatched to the invocation handler's `invoke` method in the same manner
as interface method invocations are encoded and dispatched, as described above.

The declaring class of the `Method` object passed to `invoke` will be `java.lang.Object`.

Other public methods of a proxy instance inherited from `java.lang.Object` are not overridden by a proxy class,
so invocations of those methods behave like they do for instances of `java.lang.Object`.

## 重复的方法

**Methods Duplicated in Multiple Proxy Interfaces**

When two or more interfaces of a proxy class contain a method with the same name and parameter signature,
**the order of the proxy class's interfaces becomes significant**.

> proxy interface 的顺序很重要

When such a duplicate method is invoked on a proxy instance,
the `Method` object passed to the invocation handler will not necessarily be the one
whose declaring class is assignable from the reference type of the interface that the proxy's method was invoked through.
This limitation exists because the corresponding method implementation in the generated proxy class cannot determine
which interface it was invoked through.
Therefore, when a duplicate method is invoked on a proxy instance,
the `Method` object for the method in the foremost interface
that contains the method (either directly or inherited through a superinterface)
in the proxy class's list of interfaces is passed to the invocation handler's `invoke` method,
regardless of the reference type through which the method invocation occurred.

If a proxy interface contains a method with the same name and parameter signature
as the `hashCode`, `equals`, or `toString` methods of `java.lang.Object`,
when such a method is invoked on a proxy instance,
the `Method` object passed to the invocation handler will have `java.lang.Object` as its declaring class.
In other words, the public, non-final methods of `java.lang.Object` logically precede all of the proxy interfaces
for the determination of which `Method` object to pass to the invocation handler.

> java.lang.Object 的优先级最高

Note also that when a duplicate method is dispatched to an invocation handler,
the invoke method may only throw checked exception types
that are assignable to one of the exception types in the throws clause of the method in all of the proxy interfaces
that it can be invoked through.
If the invoke method throws a checked exception that is not assignable to any of the exception types declared
by the method in one of the proxy interfaces that it can be invoked through,
then an unchecked `UndeclaredThrowableException` will be thrown by the invocation on the proxy instance.
This restriction means that not all of the exception types returned by invoking `getExceptionTypes` on the `Method` object
passed to the `invoke` method can necessarily be thrown successfully by the `invoke` method.

## 示例

### 不使用 Proxy

#### BasicOperation

```java
public interface BasicOperation {
    int add(int a, int b);

    int sub(int a, int b);
}
```

#### AdvancedOperation

```java
public interface AdvancedOperation {
    int mul(int a, int b);

    int div(int a, int b);
}
```

#### OperationImpl

```java
public class OperationImpl implements BasicOperation, AdvancedOperation {
    @Override
    public int add(int a, int b) {
        System.out.println("add");
        return a + b;
    }

    @Override
    public int sub(int a, int b) {
        System.out.println("sub");
        return a - b;
    }

    @Override
    public int mul(int a, int b) {
        return a * b;
    }

    @Override
    public int div(int a, int b) {
        return a / b;
    }
}
```

#### HelloWorld

```java
public class HelloWorld {
    public static void main(String[] args) {
        Object instance = new OperationImpl();

        BasicOperation basicOperation = (BasicOperation) instance;
        int result1 = basicOperation.add(10, 20);
        System.out.println(result1);
        System.out.println("=== === ===");

        AdvancedOperation advancedOperation = (AdvancedOperation) instance;
        int result2 = advancedOperation.mul(5, 6);
        System.out.println(result2);
        System.out.println("=== === ===");
    }
}
```

输出：

```text
add
30
=== === ===
30
=== === ===
```

### 使用 Proxy

#### OperationHandler

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Arrays;

public class OperationHandler implements InvocationHandler {
    private final Object obj;

    public OperationHandler(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // before method
        System.out.println("Enter...");
        System.out.println("proxy: " + proxy.getClass());
        System.out.println("method: " + method.getName() + " from " + method.getDeclaringClass().getName());
        System.out.println("args: " + Arrays.toString(args));

        // invoke method
        Object result = method.invoke(obj, args);

        // after method
        System.out.println("Exit...");

        return result;
    }
}
```

#### HelloWorld

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class HelloWorld {
    public static void main(String[] args) {
        OperationImpl instance = new OperationImpl();

        ClassLoader classLoader = HelloWorld.class.getClassLoader();
        Class<?>[] interfaces = new Class[]{AdvancedOperation.class, BasicOperation.class};
        InvocationHandler handler = new OperationHandler(instance);

        Object proxy = Proxy.newProxyInstance(classLoader, interfaces, handler);
        System.out.println(proxy.getClass().getName());
        System.out.println("=== === ===");

        BasicOperation basicOperation = (BasicOperation) proxy;
        int result1 = basicOperation.add(10, 20);
        System.out.println(result1);
        System.out.println("=== === ===");

        AdvancedOperation advancedOperation = (AdvancedOperation) proxy;
        int result2 = advancedOperation.mul(5, 6);
        System.out.println(result2);
        System.out.println("=== === ===");
    }
}
```

```text
com.sun.proxy.$Proxy0
=== === ===
Enter...
proxy: class com.sun.proxy.$Proxy0
method: add
args: [10, 20]
add
Exit...
30
=== === ===
Enter...
proxy: class com.sun.proxy.$Proxy0
method: mul
args: [5, 6]
Exit...
30
=== === ===
```

## 输出生成的代理类

在 `sun.misc.ProxyGenerator` 类当中，定义了 `saveGeneratedFiles` 字段，我们可以设置如下属性：

使用 Java 8：

```text
-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true
```

使用 Java 11：

```text
-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true
```

![](/assets/images/java/reflection/how-jdk-dynamic-proxy-works.png)

```java
package com.sun.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements AdvancedOperation, BasicOperation {
    private static Method hashCodeMethod;
    private static Method equalsMethod;
    private static Method toStringMethod;

    private static Method addMethod;
    private static Method subMethod;
    private static Method mulMethod;
    private static Method divMethod;

    static {
        try {
            hashCodeMethod = Class.forName("java.lang.Object").getMethod("hashCode");
            equalsMethod = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            toStringMethod = Class.forName("java.lang.Object").getMethod("toString");

            addMethod = Class.forName("sample.BasicOperation").getMethod("add", Integer.TYPE, Integer.TYPE);
            subMethod = Class.forName("sample.BasicOperation").getMethod("sub", Integer.TYPE, Integer.TYPE);
            mulMethod = Class.forName("sample.AdvancedOperation").getMethod("mul", Integer.TYPE, Integer.TYPE);
            divMethod = Class.forName("sample.AdvancedOperation").getMethod("div", Integer.TYPE, Integer.TYPE);
        }
        catch (NoSuchMethodException nsmEx) {
            throw new NoSuchMethodError(nsmEx.getMessage());
        }
        catch (ClassNotFoundException cnfEx) {
            throw new NoClassDefFoundError(cnfEx.getMessage());
        }
    }

    public $Proxy0(InvocationHandler handler) {
        super(handler);
    }

    public final int hashCode() {
        try {
            return (Integer) super.h.invoke(this, hashCodeMethod, (Object[]) null);
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }

    public final boolean equals(Object obj) {
        try {
            return (Boolean) super.h.invoke(this, equalsMethod, new Object[]{obj});
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }

    public final String toString() {
        try {
            return (String) super.h.invoke(this, toStringMethod, (Object[]) null);
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }


    public final int add(int a, int b) {
        try {
            return (Integer) super.h.invoke(this, addMethod, new Object[]{a, b});
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }

    public final int sub(int a, int b) {
        try {
            return (Integer) super.h.invoke(this, subMethod, new Object[]{a, b});
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }

    public final int mul(int a, int b) {
        try {
            return (Integer) super.h.invoke(this, mulMethod, new Object[]{a, b});
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }

    public final int div(int a, int b) {
        try {
            return (Integer) super.h.invoke(this, divMethod, new Object[]{a, b});
        }
        catch (RuntimeException | Error ex1) {
            throw ex1;
        }
        catch (Throwable ex2) {
            throw new UndeclaredThrowableException(ex2);
        }
    }
}
```

## Reference

- [Java Reflection - Dynamic Proxies](https://jenkov.com/tutorials/java-reflection/dynamic-proxies.html)

Oracle

- [Java 08: Class Proxy](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html)
- [Java 11: Class Proxy](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/Proxy.html)
- [Java 17: Class Proxy](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/reflect/Proxy.html)

