---
title: "锁的分类"
sequence: "102"
---

[UP](/java-concurrency.html)


锁的分类

- 可重入锁、不可重入锁
- 乐观锁、悲观锁
- 公平锁、非公平锁
- 互斥锁、非互斥锁


- lock
    - 获取锁之前
        - 获取方式（锁的机制）
            - 公平、非公平
    - 尝试获取锁
        - 成功
            - 自己线程:
                - reentrant
                - not reentrant
            - 其它线程
                - exclusive
                - share
        - 失败
            - 阻塞/非阻塞 - 乐观锁、悲观锁

## 可重入锁 + 不可重入锁

Java 提供的 `synchronized`、`ReentrantLock`、`ReentrantReadWriteLock` 都是可重入锁。

**重入**：当前线程获取到 A 锁，在获取之后，尝试再次获取 A 锁是可以直接拿到的。

**不可重入**：当前线程获取到 A 锁，在获取之后，尝试再次获取 A 锁，无法获取到的，
因为 A 锁被当前线程占用着，需要等待自己释放锁，再获取锁。

## 乐观锁 + 悲观锁

Java 提供的 `synchronized`、`ReentrantLock`、`ReentrantReadWriteLock` 都是悲观锁。

Java 中提供的 CAS 操作，就是乐观锁的一种实现。

### 悲观锁

**悲观锁**：总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。

悲观锁对线程有什么影响？
获取不到锁资源时，会将当前线程挂起（进入 `BLOCKED`、`WAITING` 状态），
线程挂起会涉及到**用户态**和**内核态**的切换，而这种切换是比较消耗资源的。

- 用户态：JVM 可以自行执行指令，不需要借助操作系统执行。
- 内核态：JVM 不可以自行执行，需要操作系统才可以执行。

悲观锁的实现：

- 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁；
- Java 里面的同步 `synchronized` 关键字的实现。

### 乐观锁

**乐观锁**：获取不到锁资源，可以再次让 CPU 调度，重新尝试获取锁资源。
Atomic 原子性类中，就是基于 CAS 乐观锁实现的。

乐观锁，其实就是一种思想，总是认为不会产生并发问题，每次读取数据的时候都认为其他线程不会修改数据，所以不上锁；
但是，在更新的时候会判断一下在此期间别的线程有没有修改过数据，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。

实现方式：

- CAS 实现：Java 中 `java.util.concurrent.atomic` 包下面的原子变量使用了乐观锁的一种 CAS 实现方式，CAS 分析看下节。
- 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。
  当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，
  在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功

### 适用场景

- **乐观锁**适用于**读多写少**的情况下（多读场景）
- **悲观锁**比较适用于**写多读少**场景

## 公平锁 + 非公平锁

Java 提供的 `synchronized` 只能是非公平锁。

Java 中提供的 `ReentrantLock`、`ReentrantReadWriteLock` 可以实现公平锁和非公平锁。

**公平锁**：线程 A 获取到锁资源，线程 B 没有拿到，线程 B 去排队，线程 C 来了，锁被 A 持有，同时线程 B 在排队。
线程 C 直接排到线程 B 的后面，等待 B 拿到锁资源或者是 B 取消后，才可以尝试去竞争锁资源。

**非公平锁**：线程 A 获取到了锁资源，线程 B 没有拿到，线程 B 去排队，线程 C 来了，先尝试去竞争一波

- 拿到锁资源：开心，插队成功
- 没有拿到锁资源：依然要排到 B 的后面，等待 B 拿到锁资源或者是 B 取消后，才可以尝试竞争锁资源。

## 互斥锁 + 非互斥锁

Java 提供的 `synchronized`、`ReentrantLock` 是互斥锁。

Java 提供的 `ReentrantReadWriteLock`，有互斥锁，也有共享锁。

**互斥锁**：同一时间点，只会有一个线程持有当前互斥锁。

**共享锁**：同一时间点，当前共享锁可以被多个线程同时持有。
